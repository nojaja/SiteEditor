{
    "id": "",
    "files": {
        "index.html": {
            "filename": "index.html",
            "fileType": "txt",
            "type": "text/html",
            "language": "html",
            "size": 0,
            "truncated": false,
            "content": "<html>\r\n\r\n<head>\r\n\t<link rel='stylesheet prefetch' href='main.css' />\r\n\t<meta name=\"viewport\"\r\n\t\tcontent=\"width=device-width,height=device-height,user-scalable=no,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0\">\r\n\t<script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/95/three.min.js\"></script>\r\n</head>\r\n\r\n<body>\r\n\t<!-- PWA: https://bsehovac.github.io/the-cube/ -->\r\n\r\n\t<div class=\"ui\">\r\n\r\n\t\t<div class=\"ui__background\"></div>\r\n\r\n\t\t<div class=\"ui__game\"></div>\r\n\r\n\t\t<div class=\"ui__texts\">\r\n\t\t\t<h1 class=\"text text--title\">\r\n\t\t\t\t<span>THE</span>\r\n\t\t\t\t<span>CUBE</span>\r\n\t\t\t</h1>\r\n\t\t\t<div class=\"text text--note\">\r\n\t\t\t\tDouble tap to start\r\n\t\t\t</div>\r\n\t\t\t<div class=\"text text--timer\">\r\n\t\t\t\t0:00\r\n\t\t\t</div>\r\n\t\t\t<div class=\"text text--complete\">\r\n\t\t\t\t<span>Complete!</span>\r\n\t\t\t</div>\r\n\t\t\t<div class=\"text text--best-time\">\r\n\t\t\t\t<icon trophy></icon>\r\n\t\t\t\t<span>Best Time!</span>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\r\n\t\t<div class=\"ui__prefs\">\r\n\t\t\t<range name=\"size\" title=\"Cube Size\" list=\"2,3,4,5\"></range>\r\n\t\t\t<range name=\"flip\" title=\"Flip Type\" list=\"Swift&nbsp;,Smooth,Bounce\"></range>\r\n\t\t\t<range name=\"scramble\" title=\"Scramble Length\" list=\"20,25,30\"></range>\r\n\t\t\t<range name=\"fov\" title=\"Camera Angle\" list=\"Ortographic,Perspective\"></range>\r\n\t\t\t<range name=\"theme\" title=\"Color Scheme\" list=\"Cube,Erno,Dust,Camo,Rain\"></range>\r\n\t\t</div>\r\n\r\n\t\t<div class=\"ui__theme\">\r\n\t\t\t<range name=\"hue\" title=\"Hue\" color></range>\r\n\t\t\t<range name=\"saturation\" title=\"Saturation\" color></range>\r\n\t\t\t<range name=\"lightness\" title=\"Lightness\" color></range>\r\n\t\t</div>\r\n\r\n\t\t<div class=\"ui__stats\">\r\n\t\t\t<div class=\"stats\" name=\"cube-size\">\r\n\t\t\t\t<i>Cube:</i><b>3x3x3</b>\r\n\t\t\t</div>\r\n\t\t\t<div class=\"stats\" name=\"total-solves\">\r\n\t\t\t\t<i>Total solves:</i><b>-</b>\r\n\t\t\t</div>\r\n\t\t\t<div class=\"stats\" name=\"best-time\">\r\n\t\t\t\t<i>Best time:</i><b>-</b>\r\n\t\t\t</div>\r\n\t\t\t<div class=\"stats\" name=\"worst-time\">\r\n\t\t\t\t<i>Worst time:</i><b>-</b>\r\n\t\t\t</div>\r\n\t\t\t<div class=\"stats\" name=\"average-5\">\r\n\t\t\t\t<i>Average of 5:</i><b>-</b>\r\n\t\t\t</div>\r\n\t\t\t<div class=\"stats\" name=\"average-12\">\r\n\t\t\t\t<i>Average of 12:</i><b>-</b>\r\n\t\t\t</div>\r\n\t\t\t<div class=\"stats\" name=\"average-25\">\r\n\t\t\t\t<i>Average of 25:</i><b>-</b>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\r\n\t\t<div class=\"ui__buttons\">\r\n\t\t\t<button class=\"btn btn--bl btn--stats\">\r\n      <icon trophy></icon>\r\n    </button>\r\n\t\t\t<button class=\"btn btn--br btn--prefs\">\r\n      <icon settings></icon>\r\n    </button>\r\n\t\t\t<button class=\"btn btn--bl btn--back\">\r\n      <icon back></icon>\r\n    </button>\r\n\t\t\t<button class=\"btn btn--br btn--theme\">\r\n      <icon theme></icon>\r\n    </button>\r\n\t\t\t<button class=\"btn btn--br btn--reset\">\r\n      <icon reset></icon>\r\n    </button>\r\n\t\t</div>\r\n\r\n\t</div>\r\n\t<script src=\"main.js\"></script>\r\n</body>\r\n\r\n</html>",
            "description": ""
        },
        "main.js": {
            "filename": "main.js",
            "fileType": "txt",
            "type": "text/javascript",
            "language": "JavaScript",
            "size": 0,
            "truncated": false,
            "content": "// Three.js - https://github.com/mrdoob/three.js/\r\n// RoundedBoxGeometry - https://github.com/pailhead/three-rounded-box\r\n\r\nconst animationEngine = ( () => {\r\n\r\n  let uniqueID = 0;\r\n\r\n  class AnimationEngine {\r\n\r\n    constructor() {\r\n\r\n      this.ids = [];\r\n      this.animations = {};\r\n      this.update = this.update.bind( this );\r\n      this.raf = 0;\r\n      this.time = 0;\r\n\r\n    }\r\n\r\n    update() {\r\n\r\n      const now = performance.now();\r\n      const delta = now - this.time;\r\n      this.time = now;\r\n\r\n      let i = this.ids.length;\r\n\r\n      this.raf = i ? requestAnimationFrame( this.update ) : 0;\r\n\r\n      while ( i-- )\r\n        this.animations[ this.ids[ i ] ] && this.animations[ this.ids[ i ] ].update( delta );\r\n\r\n    }\r\n\r\n    add( animation ) {\r\n\r\n      animation.id = uniqueID ++;\r\n\r\n      this.ids.push( animation.id );\r\n      this.animations[ animation.id ] = animation;\r\n\r\n      if ( this.raf !== 0 ) return;\r\n\r\n      this.time = performance.now();\r\n      this.raf = requestAnimationFrame( this.update );\r\n\r\n    }\r\n\r\n    remove( animation ) {\r\n\r\n      const index = this.ids.indexOf( animation.id );\r\n\r\n      if ( index < 0 ) return;\r\n\r\n      this.ids.splice( index, 1 );\r\n      delete this.animations[ animation.id ];\r\n      animation = null;\r\n\r\n    }\r\n\r\n  }\r\n\r\n  return new AnimationEngine();\r\n\r\n} )();\r\n\r\nclass Animation {\r\n\r\n  constructor( start ) {\r\n\r\n    if ( start === true ) this.start();\r\n\r\n  }\r\n\r\n  start() {\r\n\r\n    animationEngine.add( this );\r\n\r\n  }\r\n\r\n  stop() {\r\n\r\n    animationEngine.remove( this );\r\n\r\n  }\r\n\r\n  update( delta ) {}\r\n\r\n}\r\n\r\nclass World extends Animation {\r\n\r\n  constructor( game ) {\r\n\r\n    super( true );\r\n\r\n    this.game = game;\r\n\r\n    this.container = this.game.dom.game;\r\n    this.scene = new THREE.Scene();\r\n\r\n    this.renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );\r\n    this.renderer.setPixelRatio( window.devicePixelRatio );\r\n    this.container.appendChild( this.renderer.domElement );\r\n\r\n    this.camera = new THREE.PerspectiveCamera( 2, 1, 0.1, 10000 );\r\n\r\n    this.stage = { width: 2, height: 3 };\r\n    this.fov = 10;\r\n\r\n    this.createLights();\r\n\r\n    this.onResize = [];\r\n\r\n    this.resize();\r\n    window.addEventListener( 'resize', () => this.resize(), false );\r\n\r\n  }\r\n\r\n  update() {\r\n\r\n    this.renderer.render( this.scene, this.camera );\r\n\r\n  }\r\n\r\n  resize() {\r\n\r\n    this.width = this.container.offsetWidth;\r\n    this.height = this.container.offsetHeight;\r\n\r\n    this.renderer.setSize( this.width, this.height );\r\n\r\n    this.camera.fov = this.fov;\r\n    this.camera.aspect = this.width / this.height;\r\n\r\n    const aspect = this.stage.width / this.stage.height;\r\n    const fovRad = this.fov * THREE.Math.DEG2RAD;\r\n\r\n    let distance = ( aspect < this.camera.aspect )\r\n      ? ( this.stage.height / 2 ) / Math.tan( fovRad / 2 )\r\n      : ( this.stage.width / this.camera.aspect ) / ( 2 * Math.tan( fovRad / 2 ) );\r\n\r\n    distance *= 0.5;\r\n\r\n    this.camera.position.set( distance, distance, distance);\r\n    this.camera.lookAt( this.scene.position );\r\n    this.camera.updateProjectionMatrix();\r\n\r\n    const docFontSize = ( aspect < this.camera.aspect )\r\n      ? ( this.height / 100 ) * aspect\r\n      : this.width / 100;\r\n\r\n    document.documentElement.style.fontSize = docFontSize + 'px';\r\n\r\n    if ( this.onResize ) this.onResize.forEach( cb => cb() );\r\n\r\n  }\r\n\r\n  createLights() {\r\n\r\n    this.lights = {\r\n      holder:  new THREE.Object3D,\r\n      ambient: new THREE.AmbientLight( 0xffffff, 0.69 ),\r\n      front:   new THREE.DirectionalLight( 0xffffff, 0.36 ),\r\n      back:    new THREE.DirectionalLight( 0xffffff, 0.19 ),\r\n    };\r\n\r\n    this.lights.front.position.set( 1.5, 5, 3 );\r\n    this.lights.back.position.set( -1.5, -5, -3 );\r\n\r\n    this.lights.holder.add( this.lights.ambient );\r\n    this.lights.holder.add( this.lights.front );\r\n    this.lights.holder.add( this.lights.back );\r\n\r\n    this.scene.add( this.lights.holder );\r\n\r\n  }\r\n\r\n}\r\n\r\nfunction RoundedBoxGeometry( size, radius, radiusSegments ) {\r\n\r\n  THREE.BufferGeometry.call( this );\r\n\r\n  this.type = 'RoundedBoxGeometry';\r\n\r\n  radiusSegments = ! isNaN( radiusSegments ) ? Math.max( 1, Math.floor( radiusSegments ) ) : 1;\r\n\r\n  var width, height, depth;\r\n\r\n  width = height = depth = size;\r\n  radius = size * radius;\r\n\r\n  radius = Math.min( radius, Math.min( width, Math.min( height, Math.min( depth ) ) ) / 2 );\r\n\r\n  var edgeHalfWidth = width / 2 - radius;\r\n  var edgeHalfHeight = height / 2 - radius;\r\n  var edgeHalfDepth = depth / 2 - radius;\r\n\r\n  this.parameters = {\r\n    width: width,\r\n    height: height,\r\n    depth: depth,\r\n    radius: radius,\r\n    radiusSegments: radiusSegments\r\n  };\r\n\r\n  var rs1 = radiusSegments + 1;\r\n  var totalVertexCount = ( rs1 * radiusSegments + 1 ) << 3;\r\n\r\n  var positions = new THREE.BufferAttribute( new Float32Array( totalVertexCount * 3 ), 3 );\r\n  var normals = new THREE.BufferAttribute( new Float32Array( totalVertexCount * 3 ), 3 );\r\n\r\n  var\r\n    cornerVerts = [],\r\n    cornerNormals = [],\r\n    normal = new THREE.Vector3(),\r\n    vertex = new THREE.Vector3(),\r\n    vertexPool = [],\r\n    normalPool = [],\r\n    indices = []\r\n  ;\r\n\r\n  var\r\n    lastVertex = rs1 * radiusSegments,\r\n    cornerVertNumber = rs1 * radiusSegments + 1\r\n  ;\r\n\r\n  doVertices();\r\n  doFaces();\r\n  doCorners();\r\n  doHeightEdges();\r\n  doWidthEdges();\r\n  doDepthEdges();\r\n\r\n  function doVertices() {\r\n\r\n    var cornerLayout = [\r\n      new THREE.Vector3( 1, 1, 1 ),\r\n      new THREE.Vector3( 1, 1, - 1 ),\r\n      new THREE.Vector3( - 1, 1, - 1 ),\r\n      new THREE.Vector3( - 1, 1, 1 ),\r\n      new THREE.Vector3( 1, - 1, 1 ),\r\n      new THREE.Vector3( 1, - 1, - 1 ),\r\n      new THREE.Vector3( - 1, - 1, - 1 ),\r\n      new THREE.Vector3( - 1, - 1, 1 )\r\n    ];\r\n\r\n    for ( var j = 0; j < 8; j ++ ) {\r\n\r\n      cornerVerts.push( [] );\r\n      cornerNormals.push( [] );\r\n\r\n    }\r\n\r\n    var PIhalf = Math.PI / 2;\r\n    var cornerOffset = new THREE.Vector3( edgeHalfWidth, edgeHalfHeight, edgeHalfDepth );\r\n\r\n    for ( var y = 0; y <= radiusSegments; y ++ ) {\r\n\r\n      var v = y / radiusSegments;\r\n      var va = v * PIhalf;\r\n      var cosVa = Math.cos( va );\r\n      var sinVa = Math.sin( va );\r\n\r\n      if ( y == radiusSegments ) {\r\n\r\n        vertex.set( 0, 1, 0 );\r\n        var vert = vertex.clone().multiplyScalar( radius ).add( cornerOffset );\r\n        cornerVerts[ 0 ].push( vert );\r\n        vertexPool.push( vert );\r\n        var norm = vertex.clone();\r\n        cornerNormals[ 0 ].push( norm );\r\n        normalPool.push( norm );\r\n        continue;\r\n\r\n      }\r\n\r\n      for ( var x = 0; x <= radiusSegments; x ++ ) {\r\n\r\n        var u = x / radiusSegments;\r\n        var ha = u * PIhalf;\r\n        vertex.x = cosVa * Math.cos( ha );\r\n        vertex.y = sinVa;\r\n        vertex.z = cosVa * Math.sin( ha );\r\n\r\n        var vert = vertex.clone().multiplyScalar( radius ).add( cornerOffset );\r\n        cornerVerts[ 0 ].push( vert );\r\n        vertexPool.push( vert );\r\n\r\n        var norm = vertex.clone().normalize();\r\n        cornerNormals[ 0 ].push( norm );\r\n        normalPool.push( norm );\r\n\r\n      }\r\n\r\n    }\r\n\r\n    for ( var i = 1; i < 8; i ++ ) {\r\n\r\n      for ( var j = 0; j < cornerVerts[ 0 ].length; j ++ ) {\r\n\r\n        var vert = cornerVerts[ 0 ][ j ].clone().multiply( cornerLayout[ i ] );\r\n        cornerVerts[ i ].push( vert );\r\n        vertexPool.push( vert );\r\n\r\n        var norm = cornerNormals[ 0 ][ j ].clone().multiply( cornerLayout[ i ] );\r\n        cornerNormals[ i ].push( norm );\r\n        normalPool.push( norm );\r\n\r\n      }\r\n\r\n    }\r\n\r\n  }\r\n\r\n  function doCorners() {\r\n\r\n    var flips = [\r\n      true,\r\n      false,\r\n      true,\r\n      false,\r\n      false,\r\n      true,\r\n      false,\r\n      true\r\n    ];\r\n\r\n    var lastRowOffset = rs1 * ( radiusSegments - 1 );\r\n\r\n    for ( var i = 0; i < 8; i ++ ) {\r\n\r\n      var cornerOffset = cornerVertNumber * i;\r\n\r\n      for ( var v = 0; v < radiusSegments - 1; v ++ ) {\r\n\r\n        var r1 = v * rs1;\r\n        var r2 = ( v + 1 ) * rs1;\r\n\r\n        for ( var u = 0; u < radiusSegments; u ++ ) {\r\n\r\n          var u1 = u + 1;\r\n          var a = cornerOffset + r1 + u;\r\n          var b = cornerOffset + r1 + u1;\r\n          var c = cornerOffset + r2 + u;\r\n          var d = cornerOffset + r2 + u1;\r\n\r\n          if ( ! flips[ i ] ) {\r\n\r\n            indices.push( a );\r\n            indices.push( b );\r\n            indices.push( c );\r\n\r\n            indices.push( b );\r\n            indices.push( d );\r\n            indices.push( c );\r\n\r\n          } else {\r\n\r\n            indices.push( a );\r\n            indices.push( c );\r\n            indices.push( b );\r\n\r\n            indices.push( b );\r\n            indices.push( c );\r\n            indices.push( d );\r\n\r\n          }\r\n\r\n        }\r\n\r\n      }\r\n\r\n      for ( var u = 0; u < radiusSegments; u ++ ) {\r\n\r\n        var a = cornerOffset + lastRowOffset + u;\r\n        var b = cornerOffset + lastRowOffset + u + 1;\r\n        var c = cornerOffset + lastVertex;\r\n\r\n        if ( ! flips[ i ] ) {\r\n\r\n          indices.push( a );\r\n          indices.push( b );\r\n          indices.push( c );\r\n\r\n        } else {\r\n\r\n          indices.push( a );\r\n          indices.push( c );\r\n          indices.push( b );\r\n\r\n        }\r\n\r\n      }\r\n\r\n    }\r\n\r\n  }\r\n\r\n  function doFaces() {\r\n\r\n    var a = lastVertex;\r\n    var b = lastVertex + cornerVertNumber;\r\n    var c = lastVertex + cornerVertNumber * 2;\r\n    var d = lastVertex + cornerVertNumber * 3;\r\n\r\n    indices.push( a );\r\n    indices.push( b );\r\n    indices.push( c );\r\n    indices.push( a );\r\n    indices.push( c );\r\n    indices.push( d );\r\n\r\n    a = lastVertex + cornerVertNumber * 4;\r\n    b = lastVertex + cornerVertNumber * 5;\r\n    c = lastVertex + cornerVertNumber * 6;\r\n    d = lastVertex + cornerVertNumber * 7;\r\n\r\n    indices.push( a );\r\n    indices.push( c );\r\n    indices.push( b );\r\n    indices.push( a );\r\n    indices.push( d );\r\n    indices.push( c );\r\n\r\n    a = 0;\r\n    b = cornerVertNumber;\r\n    c = cornerVertNumber * 4;\r\n    d = cornerVertNumber * 5;\r\n\r\n    indices.push( a );\r\n    indices.push( c );\r\n    indices.push( b );\r\n    indices.push( b );\r\n    indices.push( c );\r\n    indices.push( d );\r\n\r\n    a = cornerVertNumber * 2;\r\n    b = cornerVertNumber * 3;\r\n    c = cornerVertNumber * 6;\r\n    d = cornerVertNumber * 7;\r\n\r\n    indices.push( a );\r\n    indices.push( c );\r\n    indices.push( b );\r\n    indices.push( b );\r\n    indices.push( c );\r\n    indices.push( d );\r\n\r\n    a = radiusSegments;\r\n    b = radiusSegments + cornerVertNumber * 3;\r\n    c = radiusSegments + cornerVertNumber * 4;\r\n    d = radiusSegments + cornerVertNumber * 7;\r\n\r\n    indices.push( a );\r\n    indices.push( b );\r\n    indices.push( c );\r\n    indices.push( b );\r\n    indices.push( d );\r\n    indices.push( c );\r\n\r\n    a = radiusSegments + cornerVertNumber;\r\n    b = radiusSegments + cornerVertNumber * 2;\r\n    c = radiusSegments + cornerVertNumber * 5;\r\n    d = radiusSegments + cornerVertNumber * 6;\r\n\r\n    indices.push( a );\r\n    indices.push( c );\r\n    indices.push( b );\r\n    indices.push( b );\r\n    indices.push( c );\r\n    indices.push( d );\r\n\r\n  }\r\n\r\n  function doHeightEdges() {\r\n\r\n    for ( var i = 0; i < 4; i ++ ) {\r\n\r\n      var cOffset = i * cornerVertNumber;\r\n      var cRowOffset = 4 * cornerVertNumber + cOffset;\r\n      var needsFlip = i & 1 === 1;\r\n\r\n      for ( var u = 0; u < radiusSegments; u ++ ) {\r\n\r\n        var u1 = u + 1;\r\n        var a = cOffset + u;\r\n        var b = cOffset + u1;\r\n        var c = cRowOffset + u;\r\n        var d = cRowOffset + u1;\r\n\r\n        if ( ! needsFlip ) {\r\n\r\n          indices.push( a );\r\n          indices.push( b );\r\n          indices.push( c );\r\n          indices.push( b );\r\n          indices.push( d );\r\n          indices.push( c );\r\n\r\n        } else {\r\n\r\n          indices.push( a );\r\n          indices.push( c );\r\n          indices.push( b );\r\n          indices.push( b );\r\n          indices.push( c );\r\n          indices.push( d );\r\n\r\n        }\r\n\r\n      }\r\n\r\n    }\r\n\r\n  }\r\n\r\n  function doDepthEdges() {\r\n\r\n    var cStarts = [ 0, 2, 4, 6 ];\r\n    var cEnds = [ 1, 3, 5, 7 ];\r\n\r\n    for ( var i = 0; i < 4; i ++ ) {\r\n\r\n      var cStart = cornerVertNumber * cStarts[ i ];\r\n      var cEnd = cornerVertNumber * cEnds[ i ];\r\n\r\n      var needsFlip = 1 >= i;\r\n\r\n      for ( var u = 0; u < radiusSegments; u ++ ) {\r\n\r\n        var urs1 = u * rs1;\r\n        var u1rs1 = ( u + 1 ) * rs1;\r\n\r\n        var a = cStart + urs1;\r\n        var b = cStart + u1rs1;\r\n        var c = cEnd + urs1;\r\n        var d = cEnd + u1rs1;\r\n\r\n        if ( needsFlip ) {\r\n\r\n          indices.push( a );\r\n          indices.push( c );\r\n          indices.push( b );\r\n          indices.push( b );\r\n          indices.push( c );\r\n          indices.push( d );\r\n\r\n        } else {\r\n\r\n          indices.push( a );\r\n          indices.push( b );\r\n          indices.push( c );\r\n          indices.push( b );\r\n          indices.push( d );\r\n          indices.push( c );\r\n\r\n        }\r\n\r\n      }\r\n\r\n    }\r\n\r\n  }\r\n\r\n  function doWidthEdges() {\r\n\r\n    var end = radiusSegments - 1;\r\n\r\n    var cStarts = [ 0, 1, 4, 5 ];\r\n    var cEnds = [ 3, 2, 7, 6 ];\r\n    var needsFlip = [ 0, 1, 1, 0 ];\r\n\r\n    for ( var i = 0; i < 4; i ++ ) {\r\n\r\n      var cStart = cStarts[ i ] * cornerVertNumber;\r\n      var cEnd = cEnds[ i ] * cornerVertNumber;\r\n\r\n      for ( var u = 0; u <= end; u ++ ) {\r\n\r\n        var a = cStart + radiusSegments + u * rs1;\r\n        var b = cStart + ( u != end ? radiusSegments + ( u + 1 ) * rs1 : cornerVertNumber - 1 );\r\n\r\n        var c = cEnd + radiusSegments + u * rs1;\r\n        var d = cEnd + ( u != end ? radiusSegments + ( u + 1 ) * rs1 : cornerVertNumber - 1 );\r\n\r\n        if ( ! needsFlip[ i ] ) {\r\n\r\n          indices.push( a );\r\n          indices.push( b );\r\n          indices.push( c );\r\n          indices.push( b );\r\n          indices.push( d );\r\n          indices.push( c );\r\n\r\n        } else {\r\n\r\n          indices.push( a );\r\n          indices.push( c );\r\n          indices.push( b );\r\n          indices.push( b );\r\n          indices.push( c );\r\n          indices.push( d );\r\n\r\n        }\r\n\r\n      }\r\n\r\n    }\r\n\r\n  }\r\n\r\n  var index = 0;\r\n\r\n  for ( var i = 0; i < vertexPool.length; i ++ ) {\r\n\r\n    positions.setXYZ(\r\n      index,\r\n      vertexPool[ i ].x,\r\n      vertexPool[ i ].y,\r\n      vertexPool[ i ].z\r\n    );\r\n\r\n    normals.setXYZ(\r\n      index,\r\n      normalPool[ i ].x,\r\n      normalPool[ i ].y,\r\n      normalPool[ i ].z\r\n    );\r\n\r\n    index ++;\r\n\r\n  }\r\n\r\n  this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );\r\n  this.addAttribute( 'position', positions );\r\n  this.addAttribute( 'normal', normals );\r\n\r\n}\r\n\r\nRoundedBoxGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nRoundedBoxGeometry.constructor = RoundedBoxGeometry;\r\n\r\nfunction RoundedPlaneGeometry( size, radius, depth ) {\r\n\r\n  var x, y, width, height;\r\n\r\n  x = y = - size / 2;\r\n  width = height = size;\r\n  radius = size * radius;\r\n\r\n  const shape = new THREE.Shape();\r\n\r\n  shape.moveTo( x, y + radius );\r\n  shape.lineTo( x, y + height - radius );\r\n  shape.quadraticCurveTo( x, y + height, x + radius, y + height );\r\n  shape.lineTo( x + width - radius, y + height );\r\n  shape.quadraticCurveTo( x + width, y + height, x + width, y + height - radius );\r\n  shape.lineTo( x + width, y + radius );\r\n  shape.quadraticCurveTo( x + width, y, x + width - radius, y );\r\n  shape.lineTo( x + radius, y );\r\n  shape.quadraticCurveTo( x, y, x, y + radius );\r\n\r\n  const geometry = new THREE.ExtrudeBufferGeometry(\r\n    shape,\r\n    { depth: depth, bevelEnabled: false, curveSegments: 3 }\r\n  );\r\n\r\n  return geometry;\r\n\r\n}\r\n\r\nclass Cube {\r\n\r\n  constructor( game ) {\r\n\r\n    this.game = game;\r\n    this.size = 3;\r\n\r\n    this.geometry = {\r\n      pieceCornerRadius: 0.12,\r\n      edgeCornerRoundness: 0.15,\r\n      edgeScale: 0.82,\r\n      edgeDepth: 0.01,\r\n    };\r\n\r\n    this.holder = new THREE.Object3D();\r\n    this.object = new THREE.Object3D();\r\n    this.animator = new THREE.Object3D();\r\n\r\n    this.holder.add( this.animator );\r\n    this.animator.add( this.object );\r\n\r\n    this.game.world.scene.add( this.holder );\r\n\r\n  }\r\n\r\n  init() {\r\n\r\n    this.cubes = [];\r\n    this.object.children = [];\r\n    this.object.add( this.game.controls.group );\r\n\r\n    if ( this.size === 2 ) this.scale = 1.25;\r\n    else if ( this.size === 3 ) this.scale = 1;\r\n    else if ( this.size > 3 ) this.scale = 3 / this.size;\r\n\r\n    this.object.scale.set( this.scale, this.scale, this.scale );\r\n\r\n    const controlsScale = this.size === 2 ? 0.825 : 1;\r\n    this.game.controls.edges.scale.set( controlsScale, controlsScale, controlsScale );\r\n    \r\n    this.generatePositions();\r\n    this.generateModel();\r\n\r\n    this.pieces.forEach( piece => {\r\n\r\n      this.cubes.push( piece.userData.cube );\r\n      this.object.add( piece );\r\n\r\n    } );\r\n\r\n    this.holder.traverse( node => {\r\n\r\n      if ( node.frustumCulled ) node.frustumCulled = false;\r\n\r\n    } );\r\n\r\n    this.updateColors( this.game.themes.getColors() );\r\n\r\n    this.sizeGenerated = this.size;\r\n\r\n  }\r\n\r\n  resize( force = false ) {\r\n\r\n    if ( this.size !== this.sizeGenerated || force ) {\r\n\r\n      this.size = this.game.preferences.ranges.size.value;\r\n\r\n      this.reset();\r\n      this.init();\r\n\r\n      this.game.saved = false;\r\n      this.game.timer.reset();\r\n      this.game.storage.clearGame();\r\n\r\n    }\r\n\r\n  }\r\n\r\n  reset() {\r\n\r\n    this.game.controls.edges.rotation.set( 0, 0, 0 );\r\n\r\n    this.holder.rotation.set( 0, 0, 0 );\r\n    this.object.rotation.set( 0, 0, 0 );\r\n    this.animator.rotation.set( 0, 0, 0 );\r\n\r\n  }\r\n\r\n  generatePositions() {\r\n\r\n    const m = this.size - 1;\r\n    const first = this.size % 2 !== 0\r\n      ? 0 - Math.floor(this.size / 2)\r\n      : 0.5 - this.size / 2;\r\n\r\n    let x, y, z;\r\n\r\n    this.positions = [];\r\n\r\n    for ( x = 0; x < this.size; x ++ ) {\r\n      for ( y = 0; y < this.size; y ++ ) {\r\n        for ( z = 0; z < this.size; z ++ ) {\r\n\r\n          let position = new THREE.Vector3(first + x, first + y, first + z);\r\n          let edges = [];\r\n\r\n          if ( x == 0 ) edges.push(0);\r\n          if ( x == m ) edges.push(1);\r\n          if ( y == 0 ) edges.push(2);\r\n          if ( y == m ) edges.push(3);\r\n          if ( z == 0 ) edges.push(4);\r\n          if ( z == m ) edges.push(5);\r\n\r\n          position.edges = edges;\r\n          this.positions.push( position );\r\n\r\n        }\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  generateModel() {\r\n\r\n    this.pieces = [];\r\n    this.edges = [];\r\n\r\n    const pieceSize = 1 / 3;\r\n\r\n    const mainMaterial = new THREE.MeshLambertMaterial();\r\n\r\n    const pieceMesh = new THREE.Mesh(\r\n      new RoundedBoxGeometry( pieceSize, this.geometry.pieceCornerRadius, 3 ),\r\n      mainMaterial.clone()\r\n    );\r\n\r\n    const edgeGeometry = RoundedPlaneGeometry(\r\n      pieceSize,\r\n      this.geometry.edgeCornerRoundness,\r\n      this.geometry.edgeDepth\r\n    );\r\n\r\n    this.positions.forEach( ( position, index ) => {\r\n\r\n      const piece = new THREE.Object3D();\r\n      const pieceCube = pieceMesh.clone();\r\n      const pieceEdges = [];\r\n\r\n      piece.position.copy( position.clone().divideScalar( 3 ) );\r\n      piece.add( pieceCube );\r\n      piece.name = index;\r\n      piece.edgesName = '';\r\n\r\n      position.edges.forEach( position => {\r\n\r\n        const edge = new THREE.Mesh( edgeGeometry, mainMaterial.clone() );\r\n        const name = [ 'L', 'R', 'D', 'U', 'B', 'F' ][ position ];\r\n        const distance = pieceSize / 2;\r\n\r\n        edge.position.set(\r\n          distance * [ - 1, 1, 0, 0, 0, 0 ][ position ],\r\n          distance * [ 0, 0, - 1, 1, 0, 0 ][ position ],\r\n          distance * [ 0, 0, 0, 0, - 1, 1 ][ position ]\r\n        );\r\n\r\n        edge.rotation.set(\r\n          Math.PI / 2 * [ 0, 0, 1, - 1, 0, 0 ][ position ],\r\n          Math.PI / 2 * [ - 1, 1, 0, 0, 2, 0 ][ position ],\r\n          0\r\n        );\r\n\r\n        edge.scale.set(\r\n          this.geometry.edgeScale,\r\n          this.geometry.edgeScale,\r\n          this.geometry.edgeScale\r\n        );\r\n\r\n        edge.name = name;\r\n\r\n        piece.add( edge );\r\n        pieceEdges.push( name );\r\n        this.edges.push( edge );\r\n\r\n      } );\r\n\r\n      piece.userData.edges = pieceEdges;\r\n      piece.userData.cube = pieceCube;\r\n\r\n      piece.userData.start = {\r\n        position: piece.position.clone(),\r\n        rotation: piece.rotation.clone(),\r\n      };\r\n\r\n      this.pieces.push( piece );\r\n\r\n    } );\r\n\r\n  }\r\n\r\n  updateColors( colors ) {\r\n\r\n    if ( typeof this.pieces !== 'object' && typeof this.edges !== 'object' ) return;\r\n\r\n    this.pieces.forEach( piece => piece.userData.cube.material.color.setHex( colors.P ) );\r\n    this.edges.forEach( edge => edge.material.color.setHex( colors[ edge.name ] ) );\r\n\r\n  }\r\n\r\n  loadFromData( data ) {\r\n\r\n    this.size = data.size;\r\n\r\n    this.reset();\r\n    this.init();\r\n\r\n    this.pieces.forEach( piece => {\r\n\r\n      const index = data.names.indexOf( piece.name );\r\n\r\n      const position = data.positions[index];\r\n      const rotation = data.rotations[index];\r\n\r\n      piece.position.set( position.x, position.y, position.z );\r\n      piece.rotation.set( rotation.x, rotation.y, rotation.z );\r\n\r\n    } );\r\n\r\n  }\r\n\r\n}\r\n\r\nconst Easing = {\r\n\r\n  Power: {\r\n\r\n    In: power => {\r\n\r\n      power = Math.round( power || 1 );\r\n\r\n      return t => Math.pow( t, power );\r\n\r\n    },\r\n\r\n    Out: power => {\r\n\r\n      power = Math.round( power || 1 );\r\n\r\n      return t => 1 - Math.abs( Math.pow( t - 1, power ) );\r\n\r\n    },\r\n\r\n    InOut: power => {\r\n\r\n      power = Math.round( power || 1 );\r\n\r\n      return t => ( t < 0.5 )\r\n        ? Math.pow( t * 2, power ) / 2\r\n        : ( 1 - Math.abs( Math.pow( ( t * 2 - 1 ) - 1, power ) ) ) / 2 + 0.5;\r\n\r\n    },\r\n\r\n  },\r\n\r\n  Sine: {\r\n\r\n    In: () => t => 1 + Math.sin( Math.PI / 2 * t - Math.PI / 2 ),\r\n\r\n    Out: () => t => Math.sin( Math.PI / 2 * t ),\r\n\r\n    InOut: () => t => ( 1 + Math.sin( Math.PI * t - Math.PI / 2 ) ) / 2,\r\n\r\n  },\r\n\r\n  Back: {\r\n\r\n    Out: s => {\r\n\r\n      s = s || 1.70158;\r\n\r\n      return t => { return ( t -= 1 ) * t * ( ( s + 1 ) * t + s ) + 1; };\r\n\r\n    },\r\n\r\n    In: s => {\r\n\r\n      s = s || 1.70158;\r\n\r\n      return t => { return t * t * ( ( s + 1 ) * t - s ); };\r\n\r\n    }\r\n\r\n  },\r\n\r\n  Elastic: {\r\n\r\n    Out: ( amplitude, period ) => {\r\n\r\n      let PI2 = Math.PI * 2;\r\n\r\n      let p1 = ( amplitude >= 1 ) ? amplitude : 1;\r\n      let p2 = ( period || 0.3 ) / ( amplitude < 1 ? amplitude : 1 );\r\n      let p3 = p2 / PI2 * ( Math.asin( 1 / p1 ) || 0 );\r\n\r\n      p2 = PI2 / p2;\r\n\r\n      return t => { return p1 * Math.pow( 2, -10 * t ) * Math.sin( ( t - p3 ) * p2 ) + 1 }\r\n\r\n    },\r\n\r\n  },\r\n\r\n};\r\n\r\nclass Tween extends Animation {\r\n\r\n  constructor( options ) {\r\n\r\n    super( false );\r\n\r\n    this.duration = options.duration || 500;\r\n    this.easing = options.easing || ( t => t );\r\n    this.onUpdate = options.onUpdate || ( () => {} );\r\n    this.onComplete = options.onComplete || ( () => {} );\r\n\r\n    this.delay = options.delay || false;\r\n    this.yoyo = options.yoyo ? false : null;\r\n\r\n    this.progress = 0;\r\n    this.value = 0;\r\n    this.delta = 0;\r\n\r\n    this.getFromTo( options );\r\n\r\n    if ( this.delay ) setTimeout( () => super.start(), this.delay );\r\n    else super.start();\r\n\r\n    this.onUpdate( this );\r\n\r\n  }\r\n\r\n  update( delta ) {\r\n\r\n    const old = this.value * 1;\r\n    const direction = ( this.yoyo === true ) ? - 1 : 1;\r\n\r\n    this.progress += ( delta / this.duration ) * direction;\r\n\r\n    this.value = this.easing( this.progress );\r\n    this.delta = this.value - old;\r\n\r\n    if ( this.values !== null ) this.updateFromTo();\r\n\r\n    if ( this.yoyo !== null ) this.updateYoyo();\r\n    else if ( this.progress <= 1 ) this.onUpdate( this );\r\n    else {\r\n\r\n      this.progress = 1;\r\n      this.value = 1;\r\n      this.onUpdate( this );\r\n      this.onComplete( this );\r\n      super.stop();      \r\n\r\n    }\r\n\r\n  }\r\n\r\n  updateYoyo() {\r\n\r\n    if ( this.progress > 1 || this.progress < 0 ) {\r\n\r\n      this.value = this.progress = ( this.progress > 1 ) ? 1 : 0;\r\n      this.yoyo = ! this.yoyo;\r\n\r\n    }\r\n\r\n    this.onUpdate( this );\r\n\r\n  }\r\n\r\n  updateFromTo() {\r\n\r\n    this.values.forEach( key => {\r\n\r\n      this.target[ key ] = this.from[ key ] + ( this.to[ key ] - this.from[ key ] ) * this.value;\r\n\r\n    } );\r\n\r\n  }\r\n\r\n  getFromTo( options ) {\r\n\r\n    if ( ! options.target || ! options.to ) {\r\n\r\n      this.values = null;\r\n      return;\r\n\r\n    }\r\n\r\n    this.target = options.target || null;\r\n    this.from = options.from || {};\r\n    this.to = options.to || null;\r\n    this.values = [];\r\n\r\n    if ( Object.keys( this.from ).length < 1 )\r\n      Object.keys( this.to ).forEach( key => { this.from[ key ] = this.target[ key ]; } );\r\n\r\n    Object.keys( this.to ).forEach( key => { this.values.push( key ); } );\r\n\r\n  }\r\n\r\n}\r\n\r\nwindow.addEventListener( 'touchmove', () => {} );\r\ndocument.addEventListener( 'touchmove',  event => { event.preventDefault(); }, { passive: false } );\r\n\r\nclass Draggable {\r\n\r\n  constructor( element, options ) {\r\n\r\n    this.position = {\r\n      current: new THREE.Vector2(),\r\n      start: new THREE.Vector2(),\r\n      delta: new THREE.Vector2(),\r\n      old: new THREE.Vector2(),\r\n      drag: new THREE.Vector2(),\r\n    };\r\n\r\n    this.options = Object.assign( {\r\n      calcDelta: false,\r\n    }, options || {} );\r\n\r\n    this.element = element;\r\n    this.touch = null;\r\n\r\n    this.drag = {\r\n\r\n      start: ( event ) => {\r\n\r\n        if ( event.type == 'mousedown' && event.which != 1 ) return;\r\n        if ( event.type == 'touchstart' && event.touches.length > 1 ) return;\r\n\r\n        this.getPositionCurrent( event );\r\n\r\n        if ( this.options.calcDelta ) {\r\n\r\n          this.position.start = this.position.current.clone();\r\n          this.position.delta.set( 0, 0 );\r\n          this.position.drag.set( 0, 0 );\r\n\r\n        }\r\n\r\n        this.touch = ( event.type == 'touchstart' );\r\n\r\n        this.onDragStart( this.position );\r\n\r\n        window.addEventListener( ( this.touch ) ? 'touchmove' : 'mousemove', this.drag.move, false );\r\n        window.addEventListener( ( this.touch ) ? 'touchend' : 'mouseup', this.drag.end, false );\r\n\r\n      },\r\n\r\n      move: ( event ) => {\r\n\r\n        if ( this.options.calcDelta ) {\r\n\r\n          this.position.old = this.position.current.clone();\r\n\r\n        }\r\n\r\n        this.getPositionCurrent( event );\r\n\r\n        if ( this.options.calcDelta ) {\r\n\r\n          this.position.delta = this.position.current.clone().sub( this.position.old );\r\n          this.position.drag = this.position.current.clone().sub( this.position.start );\r\n\r\n        }\r\n\r\n        this.onDragMove( this.position );\r\n\r\n      },\r\n\r\n      end: ( event ) => {\r\n\r\n        this.getPositionCurrent( event );\r\n\r\n        this.onDragEnd( this.position );\r\n\r\n        window.removeEventListener( ( this.touch ) ? 'touchmove' : 'mousemove', this.drag.move, false );\r\n        window.removeEventListener( ( this.touch ) ? 'touchend' : 'mouseup', this.drag.end, false );\r\n\r\n      },\r\n\r\n    };\r\n\r\n    this.onDragStart = () => {};\r\n    this.onDragMove = () => {};\r\n    this.onDragEnd = () => {};\r\n\r\n    this.enable();\r\n\r\n    return this;\r\n\r\n  }\r\n\r\n  enable() {\r\n\r\n    this.element.addEventListener( 'touchstart', this.drag.start, false );\r\n    this.element.addEventListener( 'mousedown', this.drag.start, false );\r\n\r\n    return this;\r\n\r\n  }\r\n\r\n  disable() {\r\n\r\n    this.element.removeEventListener( 'touchstart', this.drag.start, false );\r\n    this.element.removeEventListener( 'mousedown', this.drag.start, false );\r\n\r\n    return this;\r\n\r\n  }\r\n\r\n  getPositionCurrent( event ) {\r\n\r\n    const dragEvent = event.touches\r\n      ? ( event.touches[ 0 ] || event.changedTouches[ 0 ] )\r\n      : event;\r\n\r\n    this.position.current.set( dragEvent.pageX, dragEvent.pageY );\r\n\r\n  }\r\n\r\n  convertPosition( position ) {\r\n\r\n    position.x = ( position.x / this.element.offsetWidth ) * 2 - 1;\r\n    position.y = - ( ( position.y / this.element.offsetHeight ) * 2 - 1 );\r\n\r\n    return position;\r\n\r\n  }\r\n\r\n}\r\n\r\nconst STILL = 0;\r\nconst PREPARING = 1;\r\nconst ROTATING = 2;\r\nconst ANIMATING = 3;\r\n\r\nclass Controls {\r\n\r\n  constructor( game ) {\r\n\r\n    this.game = game;\r\n\r\n    this.flipConfig = 0;\r\n\r\n    this.flipEasings = [ Easing.Power.Out( 3 ), Easing.Sine.Out(), Easing.Back.Out( 1.5 ) ];\r\n    this.flipSpeeds = [ 125, 200, 300 ];\r\n\r\n    this.raycaster = new THREE.Raycaster();\r\n\r\n    const helperMaterial = new THREE.MeshBasicMaterial( { depthWrite: false, transparent: true, opacity: 0, color: 0x0033ff } );\r\n\r\n    this.group = new THREE.Object3D();\r\n    this.group.name = 'controls';\r\n    this.game.cube.object.add( this.group );\r\n\r\n    this.helper = new THREE.Mesh(\r\n      new THREE.PlaneBufferGeometry( 200, 200 ),\r\n      helperMaterial.clone()\r\n    );\r\n\r\n    this.helper.rotation.set( 0, Math.PI / 4, 0 );\r\n    this.game.world.scene.add( this.helper );\r\n\r\n    this.edges = new THREE.Mesh(\r\n      new THREE.BoxBufferGeometry( 1, 1, 1 ),\r\n      helperMaterial.clone(),\r\n    );\r\n\r\n    this.game.world.scene.add( this.edges );\r\n\r\n    this.onSolved = () => {};\r\n    this.onMove = () => {};\r\n\r\n    this.momentum = [];\r\n\r\n    this.scramble = null;\r\n    this.state = STILL;\r\n    this.enabled = false;\r\n\r\n    this.initDraggable();\r\n\r\n  }\r\n\r\n  enable() {\r\n\r\n    this.draggable.enable();\r\n    this.enabled = true;\r\n\r\n  }\r\n\r\n  disable() {\r\n\r\n    this.draggable.disable();\r\n    this.enabled = false;\r\n\r\n  }\r\n\r\n  initDraggable() {\r\n\r\n    this.draggable = new Draggable( this.game.dom.game );\r\n\r\n    this.draggable.onDragStart = position => {\r\n\r\n      if ( this.scramble !== null ) return;\r\n      if ( this.state === PREPARING || this.state === ROTATING ) return;\r\n\r\n      this.gettingDrag = this.state === ANIMATING;\r\n\r\n      const edgeIntersect = this.getIntersect( position.current, this.edges, false );\r\n\r\n      if ( edgeIntersect !== false ) {\r\n\r\n        this.dragIntersect = this.getIntersect( position.current, this.game.cube.cubes, true );\r\n\r\n      }\r\n\r\n      if ( edgeIntersect !== false && this.dragIntersect !== false ) {\r\n\r\n        this.dragNormal = edgeIntersect.face.normal.round();\r\n        this.flipType = 'layer';\r\n\r\n        this.attach( this.helper, this.edges );\r\n\r\n        this.helper.rotation.set( 0, 0, 0 );\r\n        this.helper.position.set( 0, 0, 0 );\r\n        this.helper.lookAt( this.dragNormal );\r\n        this.helper.translateZ( 0.5 );\r\n        this.helper.updateMatrixWorld();\r\n\r\n        this.detach( this.helper, this.edges );\r\n\r\n      } else {\r\n\r\n        this.dragNormal = new THREE.Vector3( 0, 0, 1 );\r\n        this.flipType = 'cube';\r\n\r\n        this.helper.position.set( 0, 0, 0 );\r\n        this.helper.rotation.set( 0, Math.PI / 4, 0 );\r\n        this.helper.updateMatrixWorld();\r\n\r\n      }\r\n\r\n      let planeIntersect = this.getIntersect( position.current, this.helper, false );\r\n      if ( planeIntersect === false ) return;\r\n\r\n      this.dragCurrent = this.helper.worldToLocal( planeIntersect.point );\r\n      this.dragTotal = new THREE.Vector3();\r\n      this.state = ( this.state === STILL ) ? PREPARING : this.state;\r\n\r\n    };\r\n\r\n    this.draggable.onDragMove = position => {\r\n\r\n      if ( this.scramble !== null ) return;\r\n      if ( this.state === STILL || ( this.state === ANIMATING && this.gettingDrag === false ) ) return;\r\n\r\n      const planeIntersect = this.getIntersect( position.current, this.helper, false );\r\n      if ( planeIntersect === false ) return;\r\n\r\n      const point = this.helper.worldToLocal( planeIntersect.point.clone() );\r\n\r\n      this.dragDelta = point.clone().sub( this.dragCurrent ).setZ( 0 );\r\n      this.dragTotal.add( this.dragDelta );\r\n      this.dragCurrent = point;\r\n      this.addMomentumPoint( this.dragDelta );\r\n\r\n      if ( this.state === PREPARING && this.dragTotal.length() > 0.05 ) {\r\n\r\n        this.dragDirection = this.getMainAxis( this.dragTotal );\r\n\r\n        if ( this.flipType === 'layer' ) {\r\n\r\n          const direction = new THREE.Vector3();\r\n          direction[ this.dragDirection ] = 1;\r\n\r\n          const worldDirection = this.helper.localToWorld( direction ).sub( this.helper.position );\r\n          const objectDirection = this.edges.worldToLocal( worldDirection ).round();\r\n\r\n          this.flipAxis = objectDirection.cross( this.dragNormal ).negate();\r\n\r\n          this.selectLayer( this.getLayer( false ) );\r\n\r\n        } else {\r\n\r\n          const axis = ( this.dragDirection != 'x' )\r\n            ? ( ( this.dragDirection == 'y' && position.current.x > this.game.world.width / 2 ) ? 'z' : 'x' )\r\n            : 'y';\r\n\r\n          this.flipAxis = new THREE.Vector3();\r\n          this.flipAxis[ axis ] = 1 * ( ( axis == 'x' ) ? - 1 : 1 );\r\n\r\n        }\r\n\r\n        this.flipAngle = 0;\r\n        this.state = ROTATING;\r\n\r\n      } else if ( this.state === ROTATING ) {\r\n\r\n        const rotation = this.dragDelta[ this.dragDirection ];\r\n\r\n        if ( this.flipType === 'layer' ) { \r\n\r\n          this.group.rotateOnAxis( this.flipAxis, rotation );\r\n          this.flipAngle += rotation;\r\n\r\n        } else {\r\n\r\n          this.edges.rotateOnWorldAxis( this.flipAxis, rotation );\r\n          this.game.cube.object.rotation.copy( this.edges.rotation );\r\n          this.flipAngle += rotation;\r\n\r\n        }\r\n\r\n      }\r\n\r\n    };\r\n\r\n    this.draggable.onDragEnd = position => {\r\n\r\n      if ( this.scramble !== null ) return;\r\n      if ( this.state !== ROTATING ) {\r\n\r\n        this.gettingDrag = false;\r\n        this.state = STILL;\r\n        return;\r\n\r\n      }\r\n\r\n      this.state = ANIMATING;\r\n\r\n      const momentum = this.getMomentum()[ this.dragDirection ];\r\n      const flip = ( Math.abs( momentum ) > 0.05 && Math.abs( this.flipAngle ) < Math.PI / 2 );\r\n\r\n      const angle = flip\r\n        ? this.roundAngle( this.flipAngle + Math.sign( this.flipAngle ) * ( Math.PI / 4 ) )\r\n        : this.roundAngle( this.flipAngle );\r\n\r\n      const delta = angle - this.flipAngle;\r\n\r\n      if ( this.flipType === 'layer' ) {\r\n\r\n        this.rotateLayer( delta, false, layer => {\r\n\r\n          this.game.storage.saveGame();\r\n          \r\n          this.state = this.gettingDrag ? PREPARING : STILL;\r\n          this.gettingDrag = false;\r\n\r\n          this.checkIsSolved();\r\n\r\n        } );\r\n\r\n      } else {\r\n\r\n        this.rotateCube( delta, () => {\r\n\r\n          this.state = this.gettingDrag ? PREPARING : STILL;\r\n          this.gettingDrag = false;\r\n\r\n        } );\r\n\r\n      }\r\n\r\n    };\r\n\r\n  }\r\n\r\n  rotateLayer( rotation, scramble, callback ) {\r\n\r\n    const config = scramble ? 0 : this.flipConfig;\r\n\r\n    const easing = this.flipEasings[ config ];\r\n    const duration = this.flipSpeeds[ config ];\r\n    const bounce = ( config == 2 ) ? this.bounceCube() : ( () => {} );\r\n\r\n    this.rotationTween = new Tween( {\r\n      easing: easing,\r\n      duration: duration,\r\n      onUpdate: tween => {\r\n\r\n        let deltaAngle = tween.delta * rotation;\r\n        this.group.rotateOnAxis( this.flipAxis, deltaAngle );\r\n        bounce( tween.value, deltaAngle, rotation );\r\n\r\n      },\r\n      onComplete: () => {\r\n\r\n        if ( ! scramble ) this.onMove();\r\n\r\n        const layer = this.flipLayer.slice( 0 );\r\n\r\n        this.game.cube.object.rotation.setFromVector3( this.snapRotation( this.game.cube.object.rotation.toVector3() ) );\r\n        this.group.rotation.setFromVector3( this.snapRotation( this.group.rotation.toVector3() ) );\r\n        this.deselectLayer( this.flipLayer );\r\n\r\n        callback( layer );\r\n\r\n      },\r\n    } );\r\n\r\n  }\r\n\r\n  bounceCube() {\r\n\r\n    let fixDelta = true;\r\n\r\n    return ( progress, delta, rotation ) => {\r\n\r\n        if ( progress >= 1 ) {\r\n\r\n          if ( fixDelta ) {\r\n\r\n            delta = ( progress - 1 ) * rotation;\r\n            fixDelta = false;\r\n\r\n          }\r\n\r\n          this.game.cube.object.rotateOnAxis( this.flipAxis, delta );\r\n\r\n        }\r\n\r\n    }\r\n\r\n  }\r\n\r\n  rotateCube( rotation, callback ) {\r\n\r\n    const config = this.flipConfig;\r\n    const easing = [ Easing.Power.Out( 4 ), Easing.Sine.Out(), Easing.Back.Out( 2 ) ][ config ];\r\n    const duration = [ 100, 150, 350 ][ config ];\r\n\r\n    this.rotationTween = new Tween( {\r\n      easing: easing,\r\n      duration: duration,\r\n      onUpdate: tween => {\r\n\r\n        this.edges.rotateOnWorldAxis( this.flipAxis, tween.delta * rotation );\r\n        this.game.cube.object.rotation.copy( this.edges.rotation );\r\n\r\n      },\r\n      onComplete: () => {\r\n\r\n        this.edges.rotation.setFromVector3( this.snapRotation( this.edges.rotation.toVector3() ) );\r\n        this.game.cube.object.rotation.copy( this.edges.rotation );\r\n        callback();\r\n\r\n      },\r\n    } );\r\n\r\n  }\r\n\r\n  selectLayer( layer ) {\r\n\r\n    this.group.rotation.set( 0, 0, 0 );\r\n    this.movePieces( layer, this.game.cube.object, this.group );\r\n    this.flipLayer = layer;\r\n\r\n  }\r\n\r\n  deselectLayer( layer ) {\r\n\r\n    this.movePieces( layer, this.group, this.game.cube.object );\r\n    this.flipLayer = null;\r\n\r\n  }\r\n\r\n  movePieces( layer, from, to ) {\r\n\r\n    from.updateMatrixWorld();\r\n    to.updateMatrixWorld();\r\n\r\n    layer.forEach( index => {\r\n\r\n      const piece = this.game.cube.pieces[ index ];\r\n\r\n      piece.applyMatrix( from.matrixWorld );\r\n      from.remove( piece );\r\n      piece.applyMatrix( new THREE.Matrix4().getInverse( to.matrixWorld ) );\r\n      to.add( piece );\r\n\r\n    } );\r\n\r\n  }\r\n\r\n  getLayer( position ) {\r\n\r\n    const scalar = { 2: 6, 3: 3, 4: 4, 5: 3 }[ this.game.cube.size ];\r\n    const layer = [];\r\n\r\n    let axis;\r\n\r\n    if ( position === false ) {\r\n\r\n      const piece = this.dragIntersect.object.parent;\r\n\r\n      axis = this.getMainAxis( this.flipAxis );\r\n      position = piece.position.clone() .multiplyScalar( scalar ) .round();\r\n\r\n    } else {\r\n\r\n      axis = this.getMainAxis( position );\r\n\r\n    }\r\n\r\n    this.game.cube.pieces.forEach( piece => {\r\n\r\n      const piecePosition = piece.position.clone().multiplyScalar( scalar ).round();\r\n\r\n      if ( piecePosition[ axis ] == position[ axis ] ) layer.push( piece.name );\r\n\r\n    } );\r\n\r\n    return layer;\r\n\r\n  }\r\n\r\n  keyboardMove( type, move, callback ) {\r\n\r\n    if ( this.state !== STILL ) return;\r\n    if ( this.enabled !== true ) return;\r\n\r\n    if ( type === 'LAYER' ) {\r\n\r\n      const layer = this.getLayer( move.position );\r\n\r\n      this.flipAxis = new THREE.Vector3();\r\n      this.flipAxis[ move.axis ] = 1;\r\n      this.state = ROTATING;\r\n\r\n      this.selectLayer( layer );\r\n      this.rotateLayer( move.angle, false, layer => {\r\n\r\n        this.game.storage.saveGame();\r\n        this.state = STILL;\r\n        this.checkIsSolved();\r\n\r\n      } );\r\n\r\n    } else if ( type === 'CUBE' ) {\r\n\r\n      this.flipAxis = new THREE.Vector3();\r\n      this.flipAxis[ move.axis ] = 1;\r\n      this.state = ROTATING;\r\n\r\n      this.rotateCube( move.angle, () => {\r\n\r\n        this.state = STILL;\r\n\r\n      } );\r\n\r\n    }\r\n\r\n  }\r\n\r\n  scrambleCube() {\r\n\r\n    if ( this.scramble == null ) {\r\n\r\n      this.scramble = this.game.scrambler;\r\n      this.scramble.callback = ( typeof callback !== 'function' ) ? () => {} : callback;\r\n\r\n    }\r\n\r\n    const converted = this.scramble.converted;\r\n    const move = converted[ 0 ];\r\n    const layer = this.getLayer( move.position );\r\n\r\n    this.flipAxis = new THREE.Vector3();\r\n    this.flipAxis[ move.axis ] = 1;\r\n\r\n    this.selectLayer( layer );\r\n    this.rotateLayer( move.angle, true, () => {\r\n\r\n      converted.shift();\r\n\r\n      if ( converted.length > 0 ) {\r\n\r\n        this.scrambleCube();\r\n\r\n      } else {\r\n\r\n        this.scramble = null;\r\n        this.game.storage.saveGame();\r\n\r\n      }\r\n\r\n    } );\r\n\r\n  }\r\n\r\n  getIntersect( position, object, multiple ) {\r\n\r\n    this.raycaster.setFromCamera(\r\n      this.draggable.convertPosition( position.clone() ),\r\n      this.game.world.camera\r\n    );\r\n\r\n    const intersect = ( multiple )\r\n      ? this.raycaster.intersectObjects( object )\r\n      : this.raycaster.intersectObject( object );\r\n\r\n    return ( intersect.length > 0 ) ? intersect[ 0 ] : false;\r\n\r\n  }\r\n\r\n  getMainAxis( vector ) {\r\n\r\n    return Object.keys( vector ).reduce(\r\n      ( a, b ) => Math.abs( vector[ a ] ) > Math.abs( vector[ b ] ) ? a : b\r\n    );\r\n\r\n  }\r\n\r\n  detach( child, parent ) {\r\n\r\n    child.applyMatrix( parent.matrixWorld );\r\n    parent.remove( child );\r\n    this.game.world.scene.add( child );\r\n\r\n  }\r\n\r\n  attach( child, parent ) {\r\n\r\n    child.applyMatrix( new THREE.Matrix4().getInverse( parent.matrixWorld ) );\r\n    this.game.world.scene.remove( child );\r\n    parent.add( child );\r\n\r\n  }\r\n\r\n  addMomentumPoint( delta ) {\r\n\r\n    const time = Date.now();\r\n\r\n    this.momentum = this.momentum.filter( moment => time - moment.time < 500 );\r\n\r\n    if ( delta !== false ) this.momentum.push( { delta, time } );\r\n\r\n  }\r\n\r\n  getMomentum() {\r\n\r\n    const points = this.momentum.length;\r\n    const momentum = new THREE.Vector2();\r\n\r\n    this.addMomentumPoint( false );\r\n\r\n    this.momentum.forEach( ( point, index ) => {\r\n\r\n      momentum.add( point.delta.multiplyScalar( index / points ) );\r\n\r\n    } );\r\n\r\n    return momentum;\r\n\r\n  }\r\n\r\n  roundAngle( angle ) {\r\n\r\n    const round = Math.PI / 2;\r\n    return Math.sign( angle ) * Math.round( Math.abs( angle) / round ) * round;\r\n\r\n  }\r\n\r\n  snapRotation( angle ) {\r\n\r\n    return angle.set(\r\n      this.roundAngle( angle.x ),\r\n      this.roundAngle( angle.y ),\r\n      this.roundAngle( angle.z )\r\n    );\r\n\r\n  }\r\n\r\n  checkIsSolved() {\r\n\r\n    const start = performance.now();\r\n\r\n    let solved = true;\r\n    const sides = { 'x-': [], 'x+': [], 'y-': [], 'y+': [], 'z-': [], 'z+': [] };\r\n\r\n    this.game.cube.edges.forEach( edge => {\r\n\r\n      const position = edge.parent\r\n        .localToWorld( edge.position.clone() )\r\n        .sub( this.game.cube.object.position );\r\n\r\n      const mainAxis = this.getMainAxis( position );\r\n      const mainSign = position.multiplyScalar( 2 ).round()[ mainAxis ] < 1 ? '-' : '+';\r\n\r\n      sides[ mainAxis + mainSign ].push( edge.name );\r\n\r\n    } );\r\n\r\n    Object.keys( sides ).forEach( side => {\r\n\r\n      if ( ! sides[ side ].every( value => value === sides[ side ][ 0 ] ) ) solved = false;\r\n\r\n    } );\r\n\r\n    if ( solved ) this.onSolved();\r\n\r\n  }\r\n\r\n}\r\n\r\nclass Scrambler {\r\n\r\n  constructor( game ) {\r\n\r\n    this.game = game;\r\n\r\n    this.dificulty = 0;\r\n\r\n    this.scrambleLength = {\r\n      2: [ 7, 9, 11 ],\r\n      3: [ 20, 25, 30 ],\r\n      4: [ 30, 40, 50 ],\r\n      5: [ 40, 60, 80 ],\r\n    };\r\n\r\n    this.moves = [];\r\n    this.conveted = [];\r\n    this.pring = '';\r\n\r\n  }\r\n\r\n  scramble( scramble ) {\r\n\r\n    let count = 0;\r\n    this.moves = ( typeof scramble !== 'undefined' ) ? scramble.split( ' ' ) : [];\r\n\r\n    if ( this.moves.length < 1 ) {\r\n\r\n      const scrambleLength = this.scrambleLength[ this.game.cube.size ][ this.dificulty ];\r\n\r\n      const faces = this.game.cube.size < 4 ? 'UDLRFB' : 'UuDdLlRrFfBb';\r\n      const modifiers = [ \"\", \"'\", \"2\" ];\r\n      const total = ( typeof scramble === 'undefined' ) ? scrambleLength : scramble;\r\n\r\n      while ( count < total ) {\r\n\r\n        const move =\r\n          faces[ Math.floor( Math.random() * faces.length ) ] +\r\n          modifiers[ Math.floor( Math.random() * 3 ) ];\r\n\r\n        if ( count > 0 && move.charAt( 0 ) == this.moves[ count - 1 ].charAt( 0 ) ) continue;\r\n        if ( count > 1 && move.charAt( 0 ) == this.moves[ count - 2 ].charAt( 0 ) ) continue;\r\n\r\n        this.moves.push( move );\r\n        count ++;\r\n\r\n      }\r\n\r\n    }\r\n\r\n    this.callback = () => {};\r\n    this.convert();\r\n    this.print = this.moves.join( ' ' );\r\n\r\n    return this;\r\n\r\n  }\r\n\r\n  convert( moves ) {\r\n\r\n    this.converted = [];\r\n\r\n    this.moves.forEach( move => {\r\n\r\n      const convertedMove = this.convertMove( move );\r\n      const modifier = move.charAt( 1 );\r\n\r\n      this.converted.push( convertedMove );\r\n      if ( modifier == \"2\" ) this.converted.push( convertedMove );\r\n\r\n    } );\r\n\r\n  }\r\n\r\n  convertMove( move ) {\r\n\r\n    const face = move.charAt( 0 );\r\n    const modifier = move.charAt( 1 );\r\n\r\n    const axis = { D: 'y', U: 'y', L: 'x', R: 'x', F: 'z', B: 'z' }[ face.toUpperCase() ];\r\n    let row = { D: -1, U: 1, L: -1, R: 1, F: 1, B: -1 }[ face.toUpperCase() ];\r\n\r\n    if ( this.game.cube.size > 3 && face !== face.toLowerCase() ) row = row * 2;\r\n\r\n    const position = new THREE.Vector3();\r\n    position[ { D: 'y', U: 'y', L: 'x', R: 'x', F: 'z', B: 'z' }[ face.toUpperCase() ] ] = row;\r\n\r\n    const angle = ( Math.PI / 2 ) * - row * ( ( modifier == \"'\" ) ? - 1 : 1 );\r\n\r\n    return { position, axis, angle, name: move };\r\n\r\n  }\r\n\r\n}\r\n\r\nclass Transition {\r\n\r\n  constructor( game ) {\r\n\r\n    this.game = game;\r\n\r\n    this.tweens = {};\r\n    this.durations = {};\r\n    this.data = {\r\n      cubeY: -0.2,\r\n      cameraZoom: 0.85,\r\n    };\r\n\r\n    this.activeTransitions = 0;\r\n\r\n  }\r\n\r\n  init() {\r\n\r\n    this.game.controls.disable();\r\n\r\n    this.game.cube.object.position.y = this.data.cubeY;\r\n    this.game.cube.animator.position.y = 4;\r\n    this.game.cube.animator.rotation.x = - Math.PI / 3;\r\n    this.game.world.camera.zoom = this.data.cameraZoom;\r\n    this.game.world.camera.updateProjectionMatrix();\r\n\r\n    this.tweens.buttons = {};\r\n    this.tweens.timer = [];\r\n    this.tweens.title = [];\r\n    this.tweens.best = [];\r\n    this.tweens.complete = [];\r\n    this.tweens.prefs = [];\r\n    this.tweens.theme = [];\r\n    this.tweens.stats = [];\r\n\r\n  }\r\n\r\n  buttons( show, hide ) {\r\n\r\n    const buttonTween = ( button, show ) => {\r\n\r\n      return new Tween( {\r\n        target: button.style,\r\n        duration: 300,\r\n        easing: show ? Easing.Power.Out( 2 ) : Easing.Power.In( 3 ),\r\n        from: { opacity: show ? 0 : 1 },\r\n        to: { opacity: show ? 1 : 0 },\r\n        onUpdate: tween => {\r\n\r\n          const translate = show ? 1 - tween.value : tween.value;\r\n          button.style.transform = `translate3d(0, ${translate * 1.5}em, 0)`;\r\n\r\n        },\r\n        onComplete: () => button.style.pointerEvents = show ? 'all' : 'none'\r\n      } );\r\n\r\n    };\r\n\r\n    hide.forEach( button =>\r\n      this.tweens.buttons[ button ] = buttonTween( this.game.dom.buttons[ button ], false )\r\n    );\r\n\r\n    setTimeout( () => show.forEach( button => {\r\n\r\n      this.tweens.buttons[ button ] = buttonTween( this.game.dom.buttons[ button ], true );\r\n\r\n    } ), hide ? 500 : 0 );\r\n\r\n  }\r\n\r\n  cube( show, theming = false ) {\r\n\r\n    this.activeTransitions++;\r\n\r\n    try { this.tweens.cube.stop(); } catch(e) {}\r\n    const currentY = this.game.cube.animator.position.y;\r\n    const currentRotation = this.game.cube.animator.rotation.x;\r\n\r\n    this.tweens.cube = new Tween( {\r\n      duration: show ? 3000 : 1250,\r\n      easing: show ? Easing.Elastic.Out( 0.8, 0.6 ) : Easing.Back.In( 1 ),\r\n      onUpdate: tween => {\r\n\r\n        this.game.cube.animator.position.y = show\r\n          ? ( theming ? 0.9 + ( 1 - tween.value ) * 3.5 : ( 1 - tween.value ) * 4 )\r\n          : currentY + tween.value * 4;\r\n\r\n        this.game.cube.animator.rotation.x = show\r\n          ? ( 1 - tween.value ) * Math.PI / 3\r\n          : currentRotation + tween.value * - Math.PI / 3;\r\n\r\n      },\r\n    } );\r\n\r\n    if ( theming ) {\r\n\r\n      if ( show ) {\r\n\r\n        this.game.world.camera.zoom = 0.75;\r\n        this.game.world.camera.updateProjectionMatrix();\r\n\r\n      } else {\r\n\r\n        setTimeout( () => {\r\n\r\n          this.game.world.camera.zoom = this.data.cameraZoom;\r\n          this.game.world.camera.updateProjectionMatrix();\r\n\r\n        }, 1500 );\r\n\r\n      }\r\n\r\n    }\r\n\r\n    this.durations.cube = show ? 1500 : 1500;\r\n\r\n    setTimeout( () => this.activeTransitions--, this.durations.cube );\r\n\r\n  }\r\n\r\n  float() {\r\n\r\n    try { this.tweens.float.stop(); } catch(e) {}\r\n    this.tweens.float = new Tween( {\r\n      duration: 1500,\r\n      easing: Easing.Sine.InOut(),\r\n      yoyo: true,\r\n      onUpdate: tween => {\r\n\r\n        this.game.cube.holder.position.y = (- 0.02 + tween.value * 0.04); \r\n        this.game.cube.holder.rotation.x = 0.005 - tween.value * 0.01;\r\n        this.game.cube.holder.rotation.z = - this.game.cube.holder.rotation.x;\r\n        this.game.cube.holder.rotation.y = this.game.cube.holder.rotation.x;\r\n\r\n        this.game.controls.edges.position.y =\r\n          this.game.cube.holder.position.y + this.game.cube.object.position.y;\r\n\r\n      },\r\n    } );\r\n\r\n  }\r\n\r\n  zoom( play, time ) {\r\n\r\n    this.activeTransitions++;\r\n\r\n    const zoom = ( play ) ? 1 : this.data.cameraZoom;\r\n    const duration = ( time > 0 ) ? Math.max( time, 1500 ) : 1500;\r\n    const rotations = ( time > 0 ) ? Math.round( duration / 1500 ) : 1;\r\n    const easing = Easing.Power.InOut( ( time > 0 ) ? 2 : 3 );\r\n\r\n    this.tweens.zoom = new Tween( {\r\n      target: this.game.world.camera,\r\n      duration: duration,\r\n      easing: easing,\r\n      to: { zoom: zoom },\r\n      onUpdate: () => { this.game.world.camera.updateProjectionMatrix(); },\r\n    } );\r\n\r\n    this.tweens.rotate = new Tween( {\r\n      target: this.game.cube.animator.rotation,\r\n      duration: duration,\r\n      easing: easing,\r\n      to: { y: - Math.PI * 2 * rotations },\r\n      onComplete: () => { this.game.cube.animator.rotation.y = 0; },\r\n    } );\r\n\r\n    this.durations.zoom = duration;\r\n\r\n    setTimeout( () => this.activeTransitions--, this.durations.zoom );\r\n\r\n  }\r\n\r\n  elevate( complete ) {\r\n\r\n    this.activeTransitions++;\r\n\r\n    const cubeY = \r\n\r\n    this.tweens.elevate = new Tween( {\r\n      target: this.game.cube.object.position,\r\n      duration: complete ? 1500 : 0,\r\n      easing: Easing.Power.InOut( 3 ),\r\n      to: { y: complete ? -0.05 : this.data.cubeY }\r\n    } );\r\n\r\n    this.durations.elevate = 1500;\r\n\r\n    setTimeout( () => this.activeTransitions--, this.durations.elevate );\r\n\r\n  }\r\n\r\n  complete( show, best ) {\r\n\r\n    this.activeTransitions++;\r\n\r\n    const text = best ? this.game.dom.texts.best : this.game.dom.texts.complete;\r\n\r\n    if ( text.querySelector( 'span i' ) === null )\r\n      text.querySelectorAll( 'span' ).forEach( span => this.splitLetters( span ) );\r\n\r\n    const letters = text.querySelectorAll( '.icon, i' );\r\n\r\n    this.flipLetters( best ? 'best' : 'complete', letters, show );\r\n\r\n    text.style.opacity = 1;\r\n\r\n    const duration = this.durations[ best ? 'best' : 'complete' ];\r\n\r\n    if ( ! show ) setTimeout( () => this.game.dom.texts.timer.style.transform = '', duration );\r\n\r\n    setTimeout( () => this.activeTransitions--, duration );\r\n\r\n  } \r\n\r\n  stats( show ) {\r\n\r\n    if ( show ) this.game.scores.calcStats();\r\n\r\n    this.activeTransitions++;\r\n\r\n    this.tweens.stats.forEach( tween => { tween.stop(); tween = null; } );\r\n\r\n    let tweenId = -1;\r\n\r\n    const stats = this.game.dom.stats.querySelectorAll( '.stats' );\r\n    const easing = show ? Easing.Power.Out( 2 ) : Easing.Power.In( 3 );\r\n\r\n    stats.forEach( ( stat, index ) => {\r\n\r\n      const delay = index * ( show ? 80 : 60 );\r\n\r\n      this.tweens.stats[ tweenId++ ] = new Tween( {\r\n        delay: delay,\r\n        duration: 400,\r\n        easing: easing,\r\n        onUpdate: tween => {\r\n\r\n          const translate = show ? ( 1 - tween.value ) * 2 : tween.value;\r\n          const opacity = show ? tween.value : ( 1 - tween.value );\r\n\r\n          stat.style.transform = `translate3d(0, ${translate}em, 0)`;\r\n          stat.style.opacity = opacity;\r\n\r\n        }\r\n      } );\r\n\r\n    } );\r\n\r\n    this.durations.stats = 0;\r\n\r\n    setTimeout( () => this.activeTransitions--, this.durations.stats );\r\n\r\n  }\r\n\r\n  preferences( show ) {\r\n\r\n    this.ranges( this.game.dom.prefs.querySelectorAll( '.range' ), 'prefs', show );\r\n\r\n  }\r\n\r\n  theming( show ) {\r\n\r\n    this.ranges( this.game.dom.theme.querySelectorAll( '.range' ), 'prefs', show );\r\n\r\n  }\r\n\r\n  ranges( ranges, type, show ) {\r\n\r\n    this.activeTransitions++;\r\n\r\n    this.tweens[ type ].forEach( tween => { tween.stop(); tween = null; } );\r\n\r\n    const easing = show ? Easing.Power.Out(2) : Easing.Power.In(3);\r\n\r\n    let tweenId = -1;\r\n    let listMax = 0;\r\n\r\n    ranges.forEach( ( range, rangeIndex ) => {\r\n    \r\n      const label = range.querySelector( '.range__label' );\r\n      const track = range.querySelector( '.range__track-line' );\r\n      const handle = range.querySelector( '.range__handle' );\r\n      const list = range.querySelectorAll( '.range__list div' );\r\n\r\n      const delay = rangeIndex * ( show ? 120 : 100 );\r\n\r\n      label.style.opacity = show ? 0 : 1;\r\n      track.style.opacity = show ? 0 : 1;\r\n      handle.style.opacity = show ? 0 : 1;\r\n      handle.style.pointerEvents = show ? 'all' : 'none';\r\n\r\n      this.tweens[ type ][ tweenId++ ] = new Tween( {\r\n        delay: show ? delay : delay,\r\n        duration: 400,\r\n        easing: easing,\r\n        onUpdate: tween => {\r\n\r\n          const translate = show ? ( 1 - tween.value ) : tween.value;\r\n          const opacity = show ? tween.value : ( 1 - tween.value );\r\n\r\n          label.style.transform = `translate3d(0, ${translate}em, 0)`;\r\n          label.style.opacity = opacity;\r\n\r\n        }\r\n      } );\r\n\r\n      this.tweens[ type ][ tweenId++ ] = new Tween( {\r\n        delay: show ? delay + 100 : delay,\r\n        duration: 400,\r\n        easing: easing,\r\n        onUpdate: tween => {\r\n\r\n          const translate = show ? ( 1 - tween.value ) : tween.value;\r\n          const scale = show ? tween.value : ( 1 - tween.value );\r\n          const opacity = scale;\r\n\r\n          track.style.transform = `translate3d(0, ${translate}em, 0) scale3d(${scale}, 1, 1)`;\r\n          track.style.opacity = opacity;\r\n\r\n        }\r\n      } );\r\n\r\n      this.tweens[ type ][ tweenId++ ] = new Tween( {\r\n        delay: show ? delay + 100 : delay,\r\n        duration: 400,\r\n        easing: easing,\r\n        onUpdate: tween => {\r\n\r\n          const translate = show ? ( 1 - tween.value ) : tween.value;\r\n          const opacity = 1 - translate;\r\n          const scale = 0.5 + opacity * 0.5;\r\n\r\n          handle.style.transform = `translate3d(0, ${translate}em, 0) scale3d(${scale}, ${scale}, ${scale})`;\r\n          handle.style.opacity = opacity;\r\n\r\n        }\r\n      } );\r\n\r\n      list.forEach( ( listItem, labelIndex ) => {\r\n\r\n        listItem.style.opacity = show ? 0 : 1;\r\n\r\n        this.tweens[ type ][ tweenId++ ] = new Tween( {\r\n          delay: show ? delay + 200 + labelIndex * 50 : delay,\r\n          duration: 400,\r\n          easing: easing,\r\n          onUpdate: tween => {\r\n\r\n            const translate = show ? ( 1 - tween.value ) : tween.value;\r\n            const opacity = show ? tween.value : ( 1 - tween.value );\r\n\r\n            listItem.style.transform = `translate3d(0, ${translate}em, 0)`;\r\n            listItem.style.opacity = opacity;\r\n\r\n          }\r\n        } );\r\n\r\n      } );\r\n\r\n      listMax = list.length > listMax ? list.length - 1 : listMax;\r\n\r\n      range.style.opacity = 1;\r\n\r\n    } );\r\n\r\n    this.durations[ type ] = show\r\n      ? ( ( ranges.length - 1 ) * 100 ) + 200 + listMax * 50 + 400\r\n      : ( ( ranges.length - 1 ) * 100 ) + 400;\r\n\r\n    setTimeout( () => this.activeTransitions--, this.durations[ type ] ); \r\n\r\n  }\r\n\r\n  title( show ) {\r\n\r\n    this.activeTransitions++;\r\n\r\n    const title = this.game.dom.texts.title;\r\n\r\n    if ( title.querySelector( 'span i' ) === null )\r\n      title.querySelectorAll( 'span' ).forEach( span => this.splitLetters( span ) );\r\n\r\n    const letters = title.querySelectorAll( 'i' );\r\n\r\n    this.flipLetters( 'title', letters, show );\r\n\r\n    title.style.opacity = 1;\r\n\r\n    const note = this.game.dom.texts.note;\r\n\r\n    this.tweens.title[ letters.length ] = new Tween( {\r\n      target: note.style,\r\n      easing: Easing.Sine.InOut(),\r\n      duration: show ? 800 : 400,\r\n      yoyo: show ? true : null,\r\n      from: { opacity: show ? 0 : ( parseFloat( getComputedStyle( note ).opacity ) ) },\r\n      to: { opacity: show ? 1 : 0 },\r\n    } );\r\n\r\n    setTimeout( () => this.activeTransitions--, this.durations.title );\r\n\r\n  }\r\n\r\n  timer( show ) {\r\n\r\n    this.activeTransitions++;\r\n\r\n    const timer = this.game.dom.texts.timer;\r\n\r\n    timer.style.opacity = 0;\r\n    this.game.timer.convert();\r\n    this.game.timer.setText();\r\n\r\n    this.splitLetters( timer );\r\n    const letters = timer.querySelectorAll( 'i' );\r\n    this.flipLetters( 'timer', letters, show );\r\n\r\n    timer.style.opacity = 1;\r\n\r\n    setTimeout( () => this.activeTransitions--, this.durations.timer );\r\n\r\n  }\r\n\r\n  splitLetters( element ) {\r\n\r\n    const text = element.innerHTML;\r\n\r\n    element.innerHTML = '';\r\n\r\n    text.split( '' ).forEach( letter => {\r\n\r\n      const i = document.createElement( 'i' );\r\n\r\n      i.innerHTML = letter;\r\n\r\n      element.appendChild( i );\r\n\r\n    } );\r\n\r\n  }\r\n\r\n  flipLetters( type, letters, show ) {\r\n\r\n    try { this.tweens[ type ].forEach( tween => tween.stop() ); } catch(e) {}\r\n    letters.forEach( ( letter, index ) => {\r\n\r\n      letter.style.opacity = show ? 0 : 1;\r\n\r\n      this.tweens[ type ][ index ] = new Tween( {\r\n        easing: Easing.Sine.Out(),\r\n        duration: show ? 800 : 400,\r\n        delay: index * 50,\r\n        onUpdate: tween => {\r\n\r\n          const rotation = show ? ( 1 - tween.value ) * -80 : tween.value * 80;\r\n\r\n          letter.style.transform = `rotate3d(0, 1, 0, ${rotation}deg)`;\r\n          letter.style.opacity = show ? tween.value : ( 1 - tween.value );\r\n\r\n        },\r\n      } );\r\n\r\n    } );\r\n\r\n    this.durations[ type ] = ( letters.length - 1 ) * 50 + ( show ? 800 : 400 );\r\n\r\n  }\r\n\r\n}\r\n\r\nclass Timer extends Animation {\r\n\r\n  constructor( game ) {\r\n\r\n    super( false );\r\n\r\n    this.game = game;\r\n    this.reset();\r\n    \r\n  }\r\n\r\n  start( continueGame ) {\r\n\r\n    this.startTime = continueGame ? ( Date.now() - this.deltaTime ) : Date.now();\r\n    this.deltaTime = 0;\r\n    this.converted = this.convert();\r\n\r\n    super.start();\r\n\r\n  }\r\n\r\n  reset() {\r\n\r\n    this.startTime = 0;\r\n    this.currentTime = 0;\r\n    this.deltaTime = 0;\r\n    this.converted = '0:00';\r\n\r\n  }\r\n\r\n  stop() {\r\n\r\n    this.currentTime = Date.now();\r\n    this.deltaTime = this.currentTime - this.startTime;\r\n    this.convert();\r\n\r\n    super.stop();\r\n\r\n    return { time: this.converted, millis: this.deltaTime };\r\n\r\n  }\r\n\r\n  update() {\r\n\r\n    const old = this.converted;\r\n\r\n    this.currentTime = Date.now();\r\n    this.deltaTime = this.currentTime - this.startTime;\r\n    this.convert();\r\n\r\n    if ( this.converted != old ) {\r\n\r\n      localStorage.setItem( 'theCube_time', this.deltaTime );\r\n      this.setText();\r\n\r\n    }\r\n\r\n  }\r\n\r\n  convert() {\r\n\r\n    const seconds = parseInt( ( this.deltaTime / 1000 ) % 60 );\r\n    const minutes = parseInt( ( this.deltaTime / ( 1000 * 60 ) ) );\r\n\r\n    this.converted = minutes + ':' + ( seconds < 10 ? '0' : '' ) + seconds;\r\n\r\n  }\r\n\r\n  setText() {\r\n\r\n    this.game.dom.texts.timer.innerHTML = this.converted;\r\n\r\n  }\r\n\r\n}\r\n\r\nconst RangeHTML = [\r\n\r\n  '<div class=\"range\">',\r\n    '<div class=\"range__label\"></div>',\r\n    '<div class=\"range__track\">',\r\n      '<div class=\"range__track-line\"></div>',\r\n      '<div class=\"range__handle\"><div></div></div>',\r\n    '</div>',\r\n    '<div class=\"range__list\"></div>',\r\n  '</div>',\r\n\r\n].join( '\\n' );\r\n\r\ndocument.querySelectorAll( 'range' ).forEach( el => {\r\n\r\n  const temp = document.createElement( 'div' );\r\n  temp.innerHTML = RangeHTML;\r\n\r\n  const range = temp.querySelector( '.range' );\r\n  const rangeLabel = range.querySelector( '.range__label' );\r\n  const rangeList = range.querySelector( '.range__list' );\r\n\r\n  range.setAttribute( 'name', el.getAttribute( 'name' ) );\r\n  rangeLabel.innerHTML = el.getAttribute( 'title' );\r\n\r\n  if ( el.hasAttribute( 'color' ) ) {\r\n\r\n    range.classList.add( 'range--type-color' );\r\n    range.classList.add( 'range--color-' + el.getAttribute( 'name' ) );\r\n\r\n  }\r\n\r\n  if ( el.hasAttribute( 'list' ) ) {\r\n\r\n    el.getAttribute( 'list' ).split( ',' ).forEach( listItemText => {\r\n\r\n      const listItem = document.createElement( 'div' );\r\n      listItem.innerHTML = listItemText;\r\n      rangeList.appendChild( listItem );\r\n\r\n    } );\r\n\r\n  }\r\n\r\n  el.parentNode.replaceChild( range, el );\r\n\r\n} );\r\n\r\nclass Range {\r\n\r\n  constructor( name, options ) {\r\n\r\n    options = Object.assign( {\r\n      range: [ 0, 1 ],\r\n      value: 0,\r\n      step: 0,\r\n      onUpdate: () => {},\r\n      onComplete: () => {},\r\n    }, options || {} );\r\n\r\n    this.element = document.querySelector( '.range[name=\"' + name + '\"]' );\r\n    this.track = this.element.querySelector( '.range__track' );\r\n    this.handle = this.element.querySelector( '.range__handle' );\r\n    this.list = [].slice.call( this.element.querySelectorAll( '.range__list div' ) );\r\n\r\n    this.value = options.value;\r\n    this.min = options.range[0];\r\n    this.max = options.range[1];\r\n    this.step = options.step;\r\n\r\n    this.onUpdate = options.onUpdate;\r\n    this.onComplete = options.onComplete;\r\n\r\n    this.setValue( this.value );\r\n\r\n    this.initDraggable();\r\n\r\n  }\r\n\r\n  setValue( value ) {\r\n\r\n    this.value = this.round( this.limitValue( value ) );\r\n    this.setHandlePosition();\r\n\r\n  }\r\n\r\n  initDraggable() {\r\n\r\n    let current;\r\n\r\n    this.draggable = new Draggable( this.handle, { calcDelta: true } );\r\n\r\n    this.draggable.onDragStart = position => {\r\n\r\n      current = this.positionFromValue( this.value );\r\n      this.handle.style.left = current + 'px';\r\n\r\n    };\r\n\r\n    this.draggable.onDragMove = position => {\r\n\r\n      current = this.limitPosition( current + position.delta.x );\r\n      this.value = this.round( this.valueFromPosition( current ) );\r\n      this.setHandlePosition();\r\n      \r\n      this.onUpdate( this.value );\r\n\r\n    };\r\n\r\n    this.draggable.onDragEnd = position => {\r\n\r\n      this.onComplete( this.value );\r\n\r\n    };\r\n\r\n  }\r\n\r\n  round( value ) {\r\n\r\n    if ( this.step < 1 ) return value;\r\n\r\n    return Math.round( ( value - this.min ) / this.step ) * this.step + this.min;\r\n\r\n  }\r\n\r\n  limitValue( value ) {\r\n\r\n    const max = Math.max( this.max, this.min );\r\n    const min = Math.min( this.max, this.min );\r\n\r\n    return Math.min( Math.max( value, min ), max );\r\n\r\n  }\r\n\r\n  limitPosition( position ) {\r\n\r\n    return Math.min( Math.max( position, 0 ), this.track.offsetWidth );\r\n\r\n  }\r\n\r\n  percentsFromValue( value ) {\r\n\r\n    return ( value - this.min ) / ( this.max - this.min );\r\n\r\n  }\r\n\r\n  valueFromPosition( position ) {\r\n\r\n    return this.min + ( this.max - this.min ) * ( position / this.track.offsetWidth );\r\n\r\n  }\r\n\r\n  positionFromValue( value ) {\r\n\r\n    return this.percentsFromValue( value ) * this.track.offsetWidth;\r\n\r\n  }\r\n\r\n  setHandlePosition() {\r\n\r\n    this.handle.style.left = this.percentsFromValue( this.value ) * 100 + '%';\r\n\r\n  }\r\n\r\n}\r\n\r\nclass Preferences {\r\n\r\n  constructor( game ) {\r\n\r\n    this.game = game;\r\n\r\n  }\r\n\r\n  init() {\r\n\r\n    this.ranges = {\r\n\r\n      size: new Range( 'size', {\r\n        value: this.game.cube.size,\r\n        range: [ 2, 5 ],\r\n        step: 1,\r\n        onUpdate: value => {\r\n\r\n          this.game.cube.size = value;\r\n\r\n          this.game.preferences.ranges.scramble.list.forEach( ( item, i ) => {\r\n\r\n            item.innerHTML = this.game.scrambler.scrambleLength[ this.game.cube.size ][ i ];\r\n\r\n          } );\r\n\r\n        },\r\n        onComplete: () => this.game.storage.savePreferences(),\r\n      } ),\r\n\r\n      flip: new Range( 'flip', {\r\n        value: this.game.controls.flipConfig,\r\n        range: [ 0, 2 ],\r\n        step: 1,\r\n        onUpdate: value => {\r\n\r\n          this.game.controls.flipConfig = value;\r\n\r\n        },\r\n        onComplete: () => this.game.storage.savePreferences(),\r\n      } ),\r\n\r\n      scramble: new Range( 'scramble', {\r\n        value: this.game.scrambler.dificulty,\r\n        range: [ 0, 2 ],\r\n        step: 1,\r\n        onUpdate: value => {\r\n\r\n          this.game.scrambler.dificulty = value;\r\n\r\n        },\r\n        onComplete: () => this.game.storage.savePreferences()\r\n      } ),\r\n\r\n      fov: new Range( 'fov', {\r\n        value: this.game.world.fov,\r\n        range: [ 2, 45 ],\r\n        onUpdate: value => {\r\n\r\n          this.game.world.fov = value;\r\n          this.game.world.resize();\r\n\r\n        },\r\n        onComplete: () => this.game.storage.savePreferences()\r\n      } ),\r\n\r\n      theme: new Range( 'theme', {\r\n        value: { cube: 0, erno: 1, dust: 2, camo: 3, rain: 4 }[ this.game.themes.theme ],\r\n        range: [ 0, 4 ],\r\n        step: 1,\r\n        onUpdate: value => {\r\n\r\n          const theme = [ 'cube', 'erno', 'dust', 'camo', 'rain' ][ value ];\r\n          this.game.themes.setTheme( theme );\r\n\r\n        },\r\n        onComplete: () => this.game.storage.savePreferences()\r\n      } ),\r\n\r\n      hue: new Range( 'hue', {\r\n        value: 0,\r\n        range: [ 0, 360 ],\r\n        onUpdate: value => this.game.themeEditor.updateHSL(),\r\n        onComplete: () => this.game.storage.savePreferences(),\r\n      } ),\r\n\r\n      saturation: new Range( 'saturation', {\r\n        value: 100,\r\n        range: [ 0, 100 ],\r\n        onUpdate: value => this.game.themeEditor.updateHSL(),\r\n        onComplete: () => this.game.storage.savePreferences(),\r\n      } ),\r\n\r\n      lightness: new Range( 'lightness', {\r\n        value: 50,\r\n        range: [ 0, 100 ],\r\n        onUpdate: value => this.game.themeEditor.updateHSL(),\r\n        onComplete: () => this.game.storage.savePreferences(),\r\n      } ),\r\n\r\n    };\r\n\r\n    this.ranges.scramble.list.forEach( ( item, i ) => {\r\n\r\n      item.innerHTML = this.game.scrambler.scrambleLength[ this.game.cube.size ][ i ];\r\n\r\n    } );\r\n    \r\n  }\r\n\r\n}\r\n\r\nclass Confetti {\r\n\r\n  constructor( game ) {\r\n\r\n    this.game = game;\r\n    this.started = 0;\r\n\r\n    this.options = {\r\n      speed: { min: 0.0011, max: 0.0022 },\r\n      revolution: { min: 0.01, max: 0.05 },\r\n      size: { min: 0.1, max: 0.15 },\r\n      colors: [ 0x41aac8, 0x82ca38, 0xffef48, 0xef3923, 0xff8c0a ],\r\n    };\r\n\r\n    this.geometry = new THREE.PlaneGeometry( 1, 1 );\r\n    this.material = new THREE.MeshLambertMaterial( { side: THREE.DoubleSide } );\r\n\r\n    this.holders = [\r\n      new ConfettiStage( this.game, this, 1, 20 ),\r\n      new ConfettiStage( this.game, this, -1, 30 ),\r\n    ];\r\n\r\n  }\r\n\r\n  start() {\r\n\r\n    if ( this.started > 0 ) return;\r\n\r\n    this.holders.forEach( holder => {\r\n\r\n      this.game.world.scene.add( holder.holder );\r\n      holder.start();\r\n      this.started ++;\r\n\r\n    } );\r\n\r\n  }\r\n\r\n  stop() {\r\n\r\n    if ( this.started == 0 ) return;\r\n\r\n    this.holders.forEach( holder => {\r\n\r\n      holder.stop( () => {\r\n\r\n        this.game.world.scene.remove( holder.holder );\r\n        this.started --;\r\n\r\n      } );\r\n\r\n    } );\r\n\r\n  }\r\n\r\n  updateColors( colors ) {\r\n\r\n    this.holders.forEach( holder => {\r\n\r\n      holder.options.colors.forEach( ( color, index ) => {\r\n\r\n        holder.options.colors[ index ] = colors[ [ 'D', 'F', 'R', 'B', 'L' ][ index ] ];\r\n\r\n      } );\r\n\r\n    } );\r\n\r\n  }\r\n\r\n}\r\n\r\nclass ConfettiStage extends Animation {\r\n\r\n  constructor( game, parent, distance, count ) {\r\n\r\n    super( false );\r\n\r\n    this.game = game;\r\n    this.parent = parent;\r\n\r\n    this.distanceFromCube = distance;\r\n\r\n    this.count = count;\r\n    this.particles = [];\r\n\r\n    this.holder = new THREE.Object3D();\r\n    this.holder.rotation.copy( this.game.world.camera.rotation );\r\n\r\n    this.object = new THREE.Object3D();\r\n    this.holder.add( this.object );\r\n\r\n    this.resizeViewport = this.resizeViewport.bind( this );\r\n    this.game.world.onResize.push( this.resizeViewport );\r\n    this.resizeViewport();    \r\n\r\n    this.geometry = this.parent.geometry;\r\n    this.material = this.parent.material;\r\n\r\n    this.options = this.parent.options;\r\n\r\n    let i = this.count;\r\n    while ( i-- ) this.particles.push( new Particle( this ) );\r\n\r\n  }\r\n\r\n  start() {\r\n\r\n    this.time = performance.now();\r\n    this.playing = true;\r\n\r\n    let i = this.count;\r\n    while ( i-- ) this.particles[ i ].reset();\r\n\r\n    super.start();\r\n\r\n  }\r\n\r\n  stop( callback ) {\r\n\r\n    this.playing = false;\r\n    this.completed = 0;\r\n    this.callback = callback;\r\n\r\n  }\r\n\r\n  reset() {\r\n\r\n    super.stop();\r\n\r\n    this.callback();\r\n\r\n  }\r\n\r\n  update() {\r\n\r\n    const now = performance.now();\r\n    const delta = now - this.time;\r\n    this.time = now;\r\n\r\n    let i = this.count;\r\n\r\n    while ( i-- )\r\n      if ( ! this.particles[ i ].completed ) this.particles[ i ].update( delta );\r\n\r\n    if ( ! this.playing && this.completed == this.count ) this.reset();\r\n\r\n  }\r\n\r\n  resizeViewport() {\r\n\r\n    const fovRad = this.game.world.camera.fov * THREE.Math.DEG2RAD;\r\n\r\n    this.height = 2 * Math.tan( fovRad / 2 ) * ( this.game.world.camera.position.length() - this.distanceFromCube );\r\n    this.width = this.height * this.game.world.camera.aspect;\r\n\r\n    const scale = 1 / this.game.transition.data.cameraZoom;\r\n\r\n    this.width *= scale;\r\n    this.height *= scale;\r\n\r\n    this.object.position.z = this.distanceFromCube;\r\n    this.object.position.y = this.height / 2;\r\n\r\n  }\r\n  \r\n}\r\n\r\nclass Particle {\r\n\r\n  constructor( confetti ) {\r\n\r\n    this.confetti = confetti;\r\n    this.options = this.confetti.options;\r\n\r\n    this.velocity = new THREE.Vector3();\r\n    this.force = new THREE.Vector3();\r\n\r\n    this.mesh = new THREE.Mesh( this.confetti.geometry, this.confetti.material.clone() );\r\n    this.confetti.object.add( this.mesh );\r\n\r\n    this.size = THREE.Math.randFloat( this.options.size.min, this.options.size.max );\r\n    this.mesh.scale.set( this.size, this.size, this.size );\r\n\r\n    return this;\r\n\r\n  }\r\n\r\n  reset( randomHeight = true ) {\r\n\r\n    this.completed = false;\r\n\r\n    this.color = new THREE.Color( this.options.colors[ Math.floor( Math.random() * this.options.colors.length ) ] );\r\n    this.mesh.material.color.set( this.color );\r\n\r\n    this.speed = THREE.Math.randFloat( this.options.speed.min, this.options.speed.max ) * - 1;\r\n    this.mesh.position.x = THREE.Math.randFloat( - this.confetti.width / 2, this.confetti.width / 2 );\r\n    this.mesh.position.y = ( randomHeight )\r\n      ? THREE.Math.randFloat( this.size, this.confetti.height + this.size )\r\n      : this.size;\r\n\r\n    this.revolutionSpeed = THREE.Math.randFloat( this.options.revolution.min, this.options.revolution.max );\r\n    this.revolutionAxis = [ 'x', 'y', 'z' ][ Math.floor( Math.random() * 3 ) ];\r\n    this.mesh.rotation.set( Math.random() * Math.PI / 3, Math.random() * Math.PI / 3, Math.random() * Math.PI / 3 );\r\n\r\n  }\r\n\r\n  stop() {\r\n\r\n    this.completed = true;\r\n    this.confetti.completed ++;\r\n\r\n  }\r\n\r\n  update( delta ) {\r\n\r\n    this.mesh.position.y += this.speed * delta;\r\n    this.mesh.rotation[ this.revolutionAxis ] += this.revolutionSpeed;\r\n\r\n    if ( this.mesh.position.y < - this.confetti.height - this.size )\r\n      ( this.confetti.playing ) ? this.reset( false ) : this.stop();\r\n\r\n  }\r\n\r\n}\r\n\r\nclass Scores {\r\n\r\n  constructor( game ) {\r\n\r\n    this.game = game;\r\n\r\n    this.data = {\r\n      2: {\r\n        scores: [],\r\n        solves: 0,\r\n        best: 0,\r\n        worst: 0,\r\n      },\r\n      3: {\r\n        scores: [],\r\n        solves: 0,\r\n        best: 0,\r\n        worst: 0,\r\n      },\r\n      4: {\r\n        scores: [],\r\n        solves: 0,\r\n        best: 0,\r\n        worst: 0,\r\n      },\r\n      5: {\r\n        scores: [],\r\n        solves: 0,\r\n        best: 0,\r\n        worst: 0,\r\n      }\r\n    };\r\n\r\n  }\r\n\r\n  addScore( time ) {\r\n\r\n    const data = this.data[ this.game.cube.sizeGenerated ];\r\n\r\n    data.scores.push( time );\r\n    data.solves++;\r\n\r\n    if ( data.scores.lenght > 100 ) data.scores.shift();\r\n\r\n    let bestTime = false;    \r\n\r\n    if ( time < data.best || data.best === 0 ) {\r\n\r\n      data.best = time;\r\n      bestTime = true;\r\n\r\n    }\r\n\r\n    if ( time > data.worst ) data.worst = time;\r\n\r\n    this.game.storage.saveScores();\r\n\r\n    return bestTime;\r\n\r\n  }\r\n\r\n  calcStats() {\r\n\r\n    const s = this.game.cube.sizeGenerated;\r\n    const data = this.data[ s ];\r\n\r\n    this.setStat( 'cube-size', `${s}<i>x</i>${s}<i>x</i>${s}` );\r\n    this.setStat( 'total-solves', data.solves );\r\n    this.setStat( 'best-time', this.convertTime( data.best ) );\r\n    this.setStat( 'worst-time', this.convertTime( data.worst ) );\r\n    this.setStat( 'average-5', this.getAverage( 5 ) );\r\n    this.setStat( 'average-12', this.getAverage( 12 ) );\r\n    this.setStat( 'average-25', this.getAverage( 25 ) );\r\n\r\n  }\r\n\r\n  setStat( name, value ) {\r\n\r\n    if ( value === 0 ) value = '-';\r\n\r\n    this.game.dom.stats.querySelector( `.stats[name=\"${name}\"] b` ).innerHTML = value;\r\n\r\n  }\r\n\r\n  getAverage( count ) {\r\n\r\n    const data = this.data[ this.game.cube.sizeGenerated ];\r\n\r\n    if ( data.scores.length < count ) return 0;\r\n\r\n    return this.convertTime( data.scores.slice( -count ).reduce( ( a, b ) => a + b, 0 ) / count );\r\n\r\n  }\r\n\r\n  convertTime( time ) {\r\n\r\n    if ( time <= 0 ) return 0;\r\n\r\n    const seconds = parseInt( ( time / 1000 ) % 60 );\r\n    const minutes = parseInt( ( time / ( 1000 * 60 ) ) );\r\n\r\n    return minutes + ':' + ( seconds < 10 ? '0' : '' ) + seconds;\r\n\r\n  }\r\n\r\n}\r\n\r\nclass Storage {\r\n\r\n  constructor( game ) {\r\n\r\n    this.game = game;\r\n\r\n    const userVersion = localStorage.getItem( 'theCube_version' );\r\n\r\n    if ( ! userVersion || userVersion !== window.gameVersion ) {\r\n\r\n      this.clearGame();\r\n      this.clearPreferences();\r\n      this.migrateScores();\r\n      localStorage.setItem( 'theCube_version', window.gameVersion );\r\n\r\n    }\r\n\r\n  }\r\n\r\n  init() {\r\n\r\n    this.loadPreferences();\r\n    this.loadScores();\r\n\r\n  }\r\n\r\n  loadGame() {\r\n\r\n    try {\r\n\r\n      const gameInProgress = localStorage.getItem( 'theCube_playing' ) === 'true';\r\n\r\n      if ( ! gameInProgress ) throw new Error();\r\n\r\n      const gameCubeData = JSON.parse( localStorage.getItem( 'theCube_savedState' ) );\r\n      const gameTime = parseInt( localStorage.getItem( 'theCube_time' ) );\r\n\r\n      if ( ! gameCubeData || gameTime === null ) throw new Error();\r\n      if ( gameCubeData.size !== this.game.cube.sizeGenerated ) throw new Error();\r\n\r\n      this.game.cube.loadFromData( gameCubeData );\r\n\r\n      this.game.timer.deltaTime = gameTime;\r\n\r\n      this.game.saved = true;\r\n\r\n    } catch( e ) {\r\n\r\n      this.game.saved = false;\r\n\r\n    }\r\n\r\n  }\r\n\r\n  saveGame() {\r\n\r\n    const gameInProgress = true;\r\n    const gameCubeData = { names: [], positions: [], rotations: [] };\r\n    const gameTime = this.game.timer.deltaTime;\r\n\r\n    gameCubeData.size = this.game.cube.sizeGenerated;\r\n\r\n    this.game.cube.pieces.forEach( piece => {\r\n\r\n      gameCubeData.names.push( piece.name );\r\n      gameCubeData.positions.push( piece.position );\r\n      gameCubeData.rotations.push( piece.rotation.toVector3() );\r\n\r\n    } );\r\n\r\n    localStorage.setItem( 'theCube_playing', gameInProgress );\r\n    localStorage.setItem( 'theCube_savedState', JSON.stringify( gameCubeData ) );\r\n    localStorage.setItem( 'theCube_time', gameTime );\r\n\r\n  }\r\n\r\n  clearGame() {\r\n\r\n    localStorage.removeItem( 'theCube_playing' );\r\n    localStorage.removeItem( 'theCube_savedState' );\r\n    localStorage.removeItem( 'theCube_time' );\r\n\r\n  }\r\n\r\n  loadScores() {\r\n\r\n    try {\r\n\r\n      const scoresData = JSON.parse( localStorage.getItem( 'theCube_scores' ) );\r\n\r\n      if ( ! scoresData ) throw new Error();\r\n\r\n      this.game.scores.data = scoresData;\r\n\r\n    } catch( e ) {}\r\n\r\n  }\r\n\r\n  saveScores() {\r\n\r\n    const scoresData = this.game.scores.data;\r\n\r\n    localStorage.setItem( 'theCube_scores', JSON.stringify( scoresData ) );\r\n\r\n  }\r\n\r\n  clearScores() {\r\n\r\n    localStorage.removeItem( 'theCube_scores' );\r\n\r\n  }\r\n\r\n  migrateScores() {\r\n\r\n    try {\r\n\r\n      const scoresData = JSON.parse( localStorage.getItem( 'theCube_scoresData' ) );\r\n      const scoresBest = parseInt( localStorage.getItem( 'theCube_scoresBest' ) );\r\n      const scoresWorst = parseInt( localStorage.getItem( 'theCube_scoresWorst' ) );\r\n      const scoresSolves = parseInt( localStorage.getItem( 'theCube_scoresSolves' ) );\r\n\r\n      if ( ! scoresData || ! scoresBest || ! scoresSolves || ! scoresWorst ) return false;\r\n\r\n      this.game.scores.data[ 3 ].scores = scoresData;\r\n      this.game.scores.data[ 3 ].best = scoresBest;\r\n      this.game.scores.data[ 3 ].solves = scoresSolves;\r\n      this.game.scores.data[ 3 ].worst = scoresWorst;\r\n\r\n      localStorage.removeItem( 'theCube_scoresData' );\r\n      localStorage.removeItem( 'theCube_scoresBest' );\r\n      localStorage.removeItem( 'theCube_scoresWorst' );\r\n      localStorage.removeItem( 'theCube_scoresSolves' );\r\n\r\n    } catch( e ) {}\r\n\r\n  }\r\n\r\n  loadPreferences() {\r\n\r\n    try {\r\n\r\n      const preferences = JSON.parse( localStorage.getItem( 'theCube_preferences' ) );\r\n\r\n      if ( ! preferences ) throw new Error();\r\n\r\n      this.game.cube.size = parseInt( preferences.cubeSize );\r\n      this.game.controls.flipConfig = parseInt( preferences.flipConfig );\r\n      this.game.scrambler.dificulty = parseInt( preferences.dificulty );\r\n\r\n      this.game.world.fov = parseFloat( preferences.fov );\r\n      this.game.world.resize();\r\n\r\n      this.game.themes.colors = preferences.colors;\r\n      this.game.themes.setTheme( preferences.theme );\r\n\r\n      return true;\r\n\r\n    } catch (e) {\r\n\r\n      this.game.cube.size = 3;\r\n      this.game.controls.flipConfig = 0;\r\n      this.game.scrambler.dificulty = 1;\r\n\r\n      this.game.world.fov = 10;\r\n      this.game.world.resize();\r\n\r\n      this.game.themes.setTheme( 'cube' );\r\n\r\n      this.savePreferences();\r\n\r\n      return false;\r\n\r\n    }\r\n\r\n  }\r\n\r\n  savePreferences() {\r\n\r\n    const preferences = {\r\n      cubeSize: this.game.cube.size,\r\n      flipConfig: this.game.controls.flipConfig,\r\n      dificulty: this.game.scrambler.dificulty,\r\n      fov: this.game.world.fov,\r\n      theme: this.game.themes.theme,\r\n      colors: this.game.themes.colors,\r\n    };\r\n\r\n    localStorage.setItem( 'theCube_preferences', JSON.stringify( preferences ) );\r\n\r\n  }\r\n\r\n  clearPreferences() {\r\n\r\n    localStorage.removeItem( 'theCube_preferences' );\r\n\r\n  }\r\n\r\n}\r\n\r\nclass Themes {\r\n\r\n  constructor( game ) {\r\n\r\n    this.game = game;\r\n    this.theme = null;\r\n\r\n    this.defaults = {\r\n      cube: {\r\n        U: 0xfff7ff, // white\r\n        D: 0xffef48, // yellow\r\n        F: 0xef3923, // red\r\n        R: 0x41aac8, // blue\r\n        B: 0xff8c0a, // orange\r\n        L: 0x82ca38, // green\r\n        P: 0x08101a, // piece\r\n        G: 0xd1d5db, // background\r\n      },\r\n      erno: {\r\n        U: 0xffffff,\r\n        D: 0xffd500,\r\n        F: 0xc41e3a,\r\n        R: 0x0051ba,\r\n        B: 0xff5800,\r\n        L: 0x009e60,\r\n        P: 0x08101a,\r\n        G: 0x8abdff,\r\n      },\r\n      dust: {\r\n        U: 0xfff6eb,\r\n        D: 0xe7c48d,\r\n        F: 0x8f253e,\r\n        R: 0x607e69,\r\n        B: 0xbe6f62,\r\n        L: 0x849f5d,\r\n        P: 0x08101a,\r\n        G: 0xE7C48D,\r\n      },\r\n      camo: {\r\n        U: 0xfff6eb,\r\n        D: 0xbfb672,\r\n        F: 0x37241c,\r\n        R: 0x718456,\r\n        B: 0x805831,\r\n        L: 0x37431d,\r\n        P: 0x08101a,\r\n        G: 0xBFB672,\r\n      },\r\n      rain: {\r\n        U: 0xfafaff,\r\n        D: 0xedb92d,\r\n        F: 0xce2135,\r\n        R: 0x449a89,\r\n        B: 0xec582f,\r\n        L: 0xa3a947,\r\n        P: 0x08101a,\r\n        G: 0x87b9ac,\r\n      },\r\n    };\r\n\r\n    this.colors = JSON.parse( JSON.stringify( this.defaults ) );\r\n\r\n  }\r\n\r\n  getColors() {\r\n\r\n    return this.colors[ this.theme ];\r\n\r\n  }\r\n\r\n  setTheme( theme = false, force = false ) {\r\n\r\n    if ( theme === this.theme && force === false ) return;\r\n    if ( theme !== false ) this.theme = theme;\r\n\r\n    const colors = this.getColors();\r\n\r\n    this.game.dom.prefs.querySelectorAll( '.range__handle div' ).forEach( range => {\r\n\r\n      range.style.background = '#' + colors.R.toString(16).padStart(6, '0');\r\n\r\n    } );\r\n\r\n    this.game.cube.updateColors( colors );\r\n\r\n    this.game.confetti.updateColors( colors );\r\n\r\n    this.game.dom.back.style.background = '#' + colors.G.toString(16).padStart(6, '0');\r\n\r\n  }\r\n\r\n}\r\n\r\nclass ThemeEditor {\r\n\r\n  constructor( game ) {\r\n\r\n    this.game = game;\r\n\r\n    this.editColor = 'R';\r\n\r\n    this.getPieceColor = this.getPieceColor.bind( this );\r\n\r\n  }\r\n\r\n  colorFromHSL( h, s, l ) {\r\n\r\n    h = Math.round( h );\r\n    s = Math.round( s );\r\n    l = Math.round( l );\r\n\r\n    return new THREE.Color( `hsl(${h}, ${s}%, ${l}%)` );\r\n\r\n  }\r\n\r\n  setHSL( color = null, animate = false ) {\r\n\r\n    this.editColor = ( color === null) ? 'R' : color;\r\n\r\n    const hsl = new THREE.Color( this.game.themes.getColors()[ this.editColor ] );\r\n\r\n    const { h, s, l } = hsl.getHSL( hsl );\r\n    const { hue, saturation, lightness } = this.game.preferences.ranges;\r\n\r\n    if ( animate ) {\r\n\r\n      const ho = hue.value / 360;\r\n      const so = saturation.value / 100;\r\n      const lo = lightness.value / 100;\r\n\r\n      const colorOld = this.colorFromHSL( hue.value, saturation.value, lightness.value );\r\n\r\n      if ( this.tweenHSL ) this.tweenHSL.stop();\r\n\r\n      this.tweenHSL = new Tween( {\r\n        duration: 200,\r\n        easing: Easing.Sine.Out(),\r\n        onUpdate: tween => {\r\n\r\n          hue.setValue( ( ho + ( h - ho ) * tween.value ) * 360 );\r\n          saturation.setValue( ( so + ( s - so ) * tween.value ) * 100 );\r\n          lightness.setValue( ( lo + ( l - lo ) * tween.value ) * 100 );\r\n\r\n          const colorTween = colorOld.clone().lerp( hsl, tween.value );\r\n\r\n          const colorTweenStyle = colorTween.getStyle();\r\n          const colorTweenHex = colorTween.getHSL( colorTween );\r\n\r\n          hue.handle.style.color = colorTweenStyle;\r\n          saturation.handle.style.color = colorTweenStyle;\r\n          lightness.handle.style.color = colorTweenStyle;\r\n\r\n          saturation.track.style.color =\r\n            this.colorFromHSL( colorTweenHex.h * 360, 100, 50 ).getStyle();\r\n          lightness.track.style.color =\r\n            this.colorFromHSL( colorTweenHex.h * 360, colorTweenHex.s * 100, 50 ).getStyle();\r\n\r\n          this.game.dom.theme.style.display = 'none';\r\n          this.game.dom.theme.offsetHeight;\r\n          this.game.dom.theme.style.display = '';\r\n\r\n        },\r\n        onComplete: () => {\r\n\r\n          this.updateHSL();\r\n          this.game.storage.savePreferences();\r\n\r\n        },\r\n      } );\r\n\r\n    } else {\r\n\r\n      hue.setValue( h * 360 );\r\n      saturation.setValue( s * 100 );\r\n      lightness.setValue( l * 100 );\r\n\r\n      this.updateHSL();\r\n      this.game.storage.savePreferences();\r\n\r\n    }\r\n\r\n  }\r\n\r\n  updateHSL() {\r\n\r\n    const { hue, saturation, lightness } = this.game.preferences.ranges;\r\n\r\n    const h = hue.value;\r\n    const s = saturation.value;\r\n    const l = lightness.value;\r\n\r\n    const color = this.colorFromHSL( h, s, l ).getStyle();\r\n\r\n    hue.handle.style.color = color;\r\n    saturation.handle.style.color = color;\r\n    lightness.handle.style.color = color;\r\n\r\n    saturation.track.style.color = this.colorFromHSL( h, 100, 50 ).getStyle();\r\n    lightness.track.style.color = this.colorFromHSL( h, s, 50 ).getStyle();\r\n\r\n    this.game.dom.theme.style.display = 'none';\r\n    this.game.dom.theme.offsetHeight;\r\n    this.game.dom.theme.style.display = '';\r\n\r\n    const theme = this.game.themes.theme;\r\n\r\n    this.game.themes.colors[ theme ][ this.editColor ] = this.colorFromHSL( h, s, l ).getHex();\r\n    this.game.themes.setTheme();\r\n\r\n  }\r\n\r\n  colorPicker( enable ) {\r\n\r\n    if ( enable ) {\r\n\r\n      this.game.dom.game.addEventListener( 'click', this.getPieceColor, false );\r\n\r\n    } else {\r\n\r\n      this.game.dom.game.removeEventListener( 'click', this.getPieceColor, false );\r\n\r\n    }\r\n\r\n  }\r\n\r\n  getPieceColor( event ) {\r\n\r\n    const clickEvent = event.touches\r\n      ? ( event.touches[ 0 ] || event.changedTouches[ 0 ] )\r\n      : event;\r\n\r\n    const clickPosition = new THREE.Vector2( clickEvent.pageX, clickEvent.pageY );\r\n\r\n    let edgeIntersect = this.game.controls.getIntersect( clickPosition, this.game.cube.edges, true );\r\n    let pieceIntersect = this.game.controls.getIntersect( clickPosition, this.game.cube.cubes, true );\r\n\r\n    if ( edgeIntersect !== false ) {\r\n\r\n      const edge = edgeIntersect.object;\r\n\r\n      const position = edge.parent\r\n        .localToWorld( edge.position.clone() )\r\n        .sub( this.game.cube.object.position )\r\n        .sub( this.game.cube.animator.position );\r\n\r\n      const mainAxis = this.game.controls.getMainAxis( position );\r\n      if ( position.multiplyScalar( 2 ).round()[ mainAxis ] < 1 ) edgeIntersect = false;\r\n\r\n    }\r\n\r\n    const name = edgeIntersect ? edgeIntersect.object.name : pieceIntersect ? 'P' : 'G';\r\n\r\n    this.setHSL( name, true );\r\n\r\n  }\r\n\r\n  resetTheme() {\r\n\r\n    this.game.themes.colors[ this.game.themes.theme ] =\r\n      JSON.parse( JSON.stringify( this.game.themes.defaults[ this.game.themes.theme ] ) );\r\n\r\n    this.game.themes.setTheme();\r\n\r\n    this.setHSL( this.editColor, true );\r\n\r\n  }\r\n\r\n}\r\n\r\nconst States = {\r\n  3: {\r\n    checkerboard: {\r\n      names: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26 ],\r\n      positions: [\r\n        { \"x\": 1/3, \"y\": -1/3, \"z\": 1/3 },\r\n        { \"x\": -1/3, \"y\": 1/3, \"z\": 0 },\r\n        { \"x\": 1/3, \"y\": -1/3, \"z\": -1/3 },\r\n        { \"x\": -1/3, \"y\": 0, \"z\": -1/3 },\r\n        { \"x\": 1/3, \"y\": 0, \"z\": 0 },\r\n        { \"x\": -1/3, \"y\": 0, \"z\": 1/3 },\r\n        { \"x\": 1/3, \"y\": 1/3, \"z\": 1/3 },\r\n        { \"x\": -1/3, \"y\": -1/3, \"z\": 0 },\r\n        { \"x\": 1/3, \"y\": 1/3, \"z\": -1/3 },\r\n        { \"x\": 0, \"y\": 1/3, \"z\": -1/3 },\r\n        { \"x\": 0, \"y\": -1/3, \"z\": 0 },\r\n        { \"x\": 0, \"y\": 1/3, \"z\": 1/3 },\r\n        { \"x\": 0, \"y\": 0, \"z\": 1/3 },\r\n        { \"x\": 0, \"y\": 0, \"z\": 0 },\r\n        { \"x\": 0, \"y\": 0, \"z\": -1/3 },\r\n        { \"x\": 0, \"y\": -1/3, \"z\": -1/3 },\r\n        { \"x\": 0, \"y\": 1/3, \"z\": 0 },\r\n        { \"x\": 0, \"y\": -1/3, \"z\": 1/3 },\r\n        { \"x\": -1/3, \"y\": -1/3, \"z\": 1/3 },\r\n        { \"x\": 1/3, \"y\": 1/3, \"z\": 0 },\r\n        { \"x\": -1/3, \"y\": -1/3, \"z\": -1/3 },\r\n        { \"x\": 1/3, \"y\": 0, \"z\": -1/3 },\r\n        { \"x\": -1/3, \"y\": 0, \"z\": 0 },\r\n        { \"x\": 1/3, \"y\": 0, \"z\": 1/3 },\r\n        { \"x\": -1/3, \"y\": 1/3, \"z\": 1/3 },\r\n        { \"x\": 1/3, \"y\": -1/3, \"z\": 0 },\r\n        { \"x\": -1/3, \"y\": 1/3, \"z\": -1/3 }\r\n      ],\r\n      rotations: [\r\n        { \"x\": -Math.PI, \"y\": 0, \"z\": Math.PI, },\r\n        { \"x\": Math.PI, \"y\": 0, \"z\": 0 },\r\n        { \"x\": -Math.PI, \"y\": 0, \"z\": Math.PI },\r\n        { \"x\": 0, \"y\": 0, \"z\": 0 },\r\n        { \"x\": 0, \"y\": 0, \"z\": Math.PI },\r\n        { \"x\": 0, \"y\": 0, \"z\": 0 },\r\n        { \"x\": -Math.PI, \"y\": 0, \"z\": Math.PI },\r\n        { \"x\": Math.PI, \"y\": 0, \"z\": 0 },\r\n        { \"x\": -Math.PI, \"y\": 0, \"z\": Math.PI },\r\n        { \"x\": 0, \"y\": 0, \"z\": Math.PI },\r\n        { \"x\": 0, \"y\": 0, \"z\": 0 },\r\n        { \"x\": 0, \"y\": 0, \"z\": Math.PI },\r\n        { \"x\": -Math.PI, \"y\": 0, \"z\": 0 },\r\n        { \"x\": Math.PI, \"y\": 0, \"z\": Math.PI },\r\n        { \"x\": Math.PI, \"y\": 0, \"z\": 0 },\r\n        { \"x\": 0, \"y\": 0, \"z\": Math.PI },\r\n        { \"x\": 0, \"y\": 0, \"z\": 0 },\r\n        { \"x\": 0, \"y\": 0, \"z\": Math.PI },\r\n        { \"x\": Math.PI, \"y\": 0, \"z\": Math.PI },\r\n        { \"x\": -Math.PI, \"y\": 0, \"z\": 0 },\r\n        { \"x\": Math.PI, \"y\": 0, \"z\": Math.PI },\r\n        { \"x\": 0, \"y\": 0, \"z\": 0 },\r\n        { \"x\": 0, \"y\": 0, \"z\": Math.PI },\r\n        { \"x\": 0, \"y\": 0, \"z\": 0 },\r\n        { \"x\": Math.PI, \"y\": 0, \"z\": Math.PI },\r\n        { \"x\": -Math.PI, \"y\": 0, \"z\": 0 },\r\n        { \"x\": Math.PI, \"y\": 0, \"z\": Math.PI }\r\n      ],\r\n      size: 3,\r\n    },\r\n  }\r\n};\r\n\r\nclass IconsConverter {\r\n\r\n  constructor( options ) {\r\n\r\n    options = Object.assign( {\r\n      tagName: 'icon',\r\n      className: 'icon',\r\n      styles: false,\r\n      icons: {},\r\n      observe: false,\r\n      convert: false,\r\n    }, options || {} );\r\n\r\n    this.tagName = options.tagName;\r\n    this.className = options.className;\r\n    this.icons = options.icons;\r\n\r\n    this.svgTag = document.createElementNS( 'http://www.w3.org/2000/svg', 'svg' );\r\n    this.svgTag.setAttribute( 'class', this.className );\r\n\r\n    if ( options.styles ) this.addStyles();\r\n    if ( options.convert ) this.convertAllIcons();\r\n\r\n    if ( options.observe ) {\r\n\r\n      const MutationObserver = window.MutationObserver || window.WebKitMutationObserver;\r\n      this.observer = new MutationObserver( mutations => { this.convertAllIcons(); } );\r\n      this.observer.observe( document.documentElement, { childList: true, subtree: true } );\r\n\r\n    }\r\n\r\n    return this;\r\n\r\n  }\r\n\r\n  convertAllIcons() {\r\n\r\n    document.querySelectorAll( this.tagName ).forEach( icon => { this.convertIcon( icon ); } );\r\n\r\n  }\r\n\r\n  convertIcon( icon ) {\r\n\r\n    const svgData = this.icons[ icon.attributes[0].localName ];\r\n\r\n    if ( typeof svgData === 'undefined' ) return;\r\n\r\n    const svg = this.svgTag.cloneNode( true );\r\n    const viewBox = svgData.viewbox.split( ' ' );\r\n\r\n    svg.setAttributeNS( null, 'viewBox', svgData.viewbox );\r\n    svg.style.width = viewBox[2] / viewBox[3] + 'em';\r\n    svg.style.height = '1em';\r\n    svg.innerHTML = svgData.content;\r\n\r\n    icon.parentNode.replaceChild( svg, icon );\r\n\r\n  }\r\n\r\n  addStyles() {\r\n\r\n    const style = document.createElement( 'style' );\r\n    style.innerHTML = `.${this.className} { display: inline-block; font-size: inherit; overflow: visible; vertical-align: -0.125em; preserveAspectRatio: none; }`;\r\n    document.head.appendChild( style );\r\n\r\n  }\r\n\r\n}\r\n\r\nconst Icons = new IconsConverter( {\r\n\r\n  icons: {\r\n    settings: {\r\n      viewbox: '0 0 512 512',\r\n      content: '<path fill=\"currentColor\" d=\"M444.788 291.1l42.616 24.599c4.867 2.809 7.126 8.618 5.459 13.985-11.07 35.642-29.97 67.842-54.689 94.586a12.016 12.016 0 0 1-14.832 2.254l-42.584-24.595a191.577 191.577 0 0 1-60.759 35.13v49.182a12.01 12.01 0 0 1-9.377 11.718c-34.956 7.85-72.499 8.256-109.219.007-5.49-1.233-9.403-6.096-9.403-11.723v-49.184a191.555 191.555 0 0 1-60.759-35.13l-42.584 24.595a12.016 12.016 0 0 1-14.832-2.254c-24.718-26.744-43.619-58.944-54.689-94.586-1.667-5.366.592-11.175 5.459-13.985L67.212 291.1a193.48 193.48 0 0 1 0-70.199l-42.616-24.599c-4.867-2.809-7.126-8.618-5.459-13.985 11.07-35.642 29.97-67.842 54.689-94.586a12.016 12.016 0 0 1 14.832-2.254l42.584 24.595a191.577 191.577 0 0 1 60.759-35.13V25.759a12.01 12.01 0 0 1 9.377-11.718c34.956-7.85 72.499-8.256 109.219-.007 5.49 1.233 9.403 6.096 9.403 11.723v49.184a191.555 191.555 0 0 1 60.759 35.13l42.584-24.595a12.016 12.016 0 0 1 14.832 2.254c24.718 26.744 43.619 58.944 54.689 94.586 1.667 5.366-.592 11.175-5.459 13.985L444.788 220.9a193.485 193.485 0 0 1 0 70.2zM336 256c0-44.112-35.888-80-80-80s-80 35.888-80 80 35.888 80 80 80 80-35.888 80-80z\" />',\r\n    },\r\n    back: {\r\n      viewbox: '0 0 512 512',\r\n      content: '<path transform=\"translate(512, 0) scale(-1,1)\" fill=\"currentColor\" d=\"M503.691 189.836L327.687 37.851C312.281 24.546 288 35.347 288 56.015v80.053C127.371 137.907 0 170.1 0 322.326c0 61.441 39.581 122.309 83.333 154.132 13.653 9.931 33.111-2.533 28.077-18.631C66.066 312.814 132.917 274.316 288 272.085V360c0 20.7 24.3 31.453 39.687 18.164l176.004-152c11.071-9.562 11.086-26.753 0-36.328z\" />',\r\n    },\r\n    trophy: {\r\n      viewbox: '0 0 576 512',\r\n      content: '<path fill=\"currentColor\" d=\"M552 64H448V24c0-13.3-10.7-24-24-24H152c-13.3 0-24 10.7-24 24v40H24C10.7 64 0 74.7 0 88v56c0 66.5 77.9 131.7 171.9 142.4C203.3 338.5 240 360 240 360v72h-48c-35.3 0-64 20.7-64 56v12c0 6.6 5.4 12 12 12h296c6.6 0 12-5.4 12-12v-12c0-35.3-28.7-56-64-56h-48v-72s36.7-21.5 68.1-73.6C498.4 275.6 576 210.3 576 144V88c0-13.3-10.7-24-24-24zM64 144v-16h64.2c1 32.6 5.8 61.2 12.8 86.2-47.5-16.4-77-49.9-77-70.2zm448 0c0 20.2-29.4 53.8-77 70.2 7-25 11.8-53.6 12.8-86.2H512v16zm-127.3 4.7l-39.6 38.6 9.4 54.6c1.7 9.8-8.7 17.2-17.4 12.6l-49-25.8-49 25.8c-8.8 4.6-19.1-2.9-17.4-12.6l9.4-54.6-39.6-38.6c-7.1-6.9-3.2-19 6.7-20.5l54.8-8 24.5-49.6c4.4-8.9 17.1-8.9 21.5 0l24.5 49.6 54.8 8c9.6 1.5 13.5 13.6 6.4 20.5z\" />',\r\n    },\r\n    cancel: {\r\n      viewbox: '0 0 352 512',\r\n      content: '<path fill=\"currentColor\" d=\"M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z\" />',\r\n    },\r\n    theme: {\r\n      viewbox: '0 0 512 512',\r\n      content: '<path fill=\"currentColor\" d=\"M204.3 5C104.9 24.4 24.8 104.3 5.2 203.4c-37 187 131.7 326.4 258.8 306.7 41.2-6.4 61.4-54.6 42.5-91.7-23.1-45.4 9.9-98.4 60.9-98.4h79.7c35.8 0 64.8-29.6 64.9-65.3C511.5 97.1 368.1-26.9 204.3 5zM96 320c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm32-128c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128-64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128 64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32z\"/>',\r\n    },\r\n    reset: {\r\n      viewbox: '0 0 512 512',\r\n      content: '<path fill=\"currentColor\" d=\"M370.72 133.28C339.458 104.008 298.888 87.962 255.848 88c-77.458.068-144.328 53.178-162.791 126.85-1.344 5.363-6.122 9.15-11.651 9.15H24.103c-7.498 0-13.194-6.807-11.807-14.176C33.933 94.924 134.813 8 256 8c66.448 0 126.791 26.136 171.315 68.685L463.03 40.97C478.149 25.851 504 36.559 504 57.941V192c0 13.255-10.745 24-24 24H345.941c-21.382 0-32.09-25.851-16.971-40.971l41.75-41.749zM32 296h134.059c21.382 0 32.09 25.851 16.971 40.971l-41.75 41.75c31.262 29.273 71.835 45.319 114.876 45.28 77.418-.07 144.315-53.144 162.787-126.849 1.344-5.363 6.122-9.15 11.651-9.15h57.304c7.498 0 13.194 6.807 11.807 14.176C478.067 417.076 377.187 504 256 504c-66.448 0-126.791-26.136-171.315-68.685L48.97 471.03C33.851 486.149 8 475.441 8 454.059V320c0-13.255 10.745-24 24-24z\" />',\r\n    },\r\n    trash: {\r\n      viewbox: '0 0 448 512',\r\n      content: '<path fill=\"currentColor\" d=\"M432 32H312l-9.4-18.7A24 24 0 0 0 281.1 0H166.8a23.72 23.72 0 0 0-21.4 13.3L136 32H16A16 16 0 0 0 0 48v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16zM53.2 467a48 48 0 0 0 47.9 45h245.8a48 48 0 0 0 47.9-45L416 128H32z\" />',\r\n    },\r\n  },\r\n\r\n  convert: true,\r\n\r\n} );\r\n\r\nconst STATE = {\r\n  Menu: 0,\r\n  Playing: 1,\r\n  Complete: 2,\r\n  Stats: 3,\r\n  Prefs: 4,\r\n  Theme: 5,\r\n};\r\n\r\nconst BUTTONS = {\r\n  Menu: [ 'stats', 'prefs' ],\r\n  Playing: [ 'back' ],\r\n  Complete: [],\r\n  Stats: [],\r\n  Prefs: [ 'back', 'theme' ],\r\n  Theme: [ 'back', 'reset' ],\r\n  None: [],\r\n};\r\n\r\nconst SHOW = true;\r\nconst HIDE = false;\r\n\r\nclass Game {\r\n\r\n  constructor() {\r\n\r\n    this.dom = {\r\n      ui: document.querySelector( '.ui' ),\r\n      game: document.querySelector( '.ui__game' ),\r\n      back: document.querySelector( '.ui__background' ),\r\n      prefs: document.querySelector( '.ui__prefs' ),\r\n      theme: document.querySelector( '.ui__theme' ),\r\n      stats: document.querySelector( '.ui__stats' ),\r\n      texts: {\r\n        title: document.querySelector( '.text--title' ),\r\n        note: document.querySelector( '.text--note' ),\r\n        timer: document.querySelector( '.text--timer' ),\r\n        complete: document.querySelector( '.text--complete' ),\r\n        best: document.querySelector( '.text--best-time' ),\r\n        theme: document.querySelector( '.text--theme' ),\r\n      },\r\n      buttons: {\r\n        prefs: document.querySelector( '.btn--prefs' ),\r\n        back: document.querySelector( '.btn--back' ),\r\n        stats: document.querySelector( '.btn--stats' ),\r\n        reset: document.querySelector( '.btn--reset' ),\r\n        theme: document.querySelector( '.btn--theme' ),\r\n      },\r\n    };\r\n\r\n    this.world = new World( this );\r\n    this.cube = new Cube( this );\r\n    this.controls = new Controls( this );\r\n    this.scrambler = new Scrambler( this );\r\n    this.transition = new Transition( this );\r\n    this.timer = new Timer( this );\r\n    this.preferences = new Preferences( this );\r\n    this.scores = new Scores( this );\r\n    this.storage = new Storage( this );\r\n    this.confetti = new Confetti( this );\r\n    this.themes = new Themes( this );\r\n    this.themeEditor = new ThemeEditor( this );\r\n\r\n    this.initActions();\r\n\r\n    this.state = STATE.Menu;\r\n    this.newGame = false;\r\n    this.saved = false;\r\n\r\n    this.storage.init();\r\n    this.preferences.init();\r\n    this.cube.init();\r\n    this.transition.init();\r\n\r\n    this.storage.loadGame();\r\n    this.scores.calcStats();\r\n\r\n    setTimeout( () => {\r\n\r\n      this.transition.float();\r\n      this.transition.cube( SHOW );\r\n\r\n      setTimeout( () => this.transition.title( SHOW ), 700 );\r\n      setTimeout( () => this.transition.buttons( BUTTONS.Menu, BUTTONS.None ), 1000 );\r\n\r\n    }, 500 );\r\n\r\n  }\r\n\r\n  initActions() {\r\n\r\n    let tappedTwice = false;\r\n\r\n    this.dom.game.addEventListener( 'click', event => {\r\n\r\n      if ( this.transition.activeTransitions > 0 ) return;\r\n      if ( this.state === STATE.Playing ) return;\r\n\r\n      if ( this.state === STATE.Menu ) {\r\n\r\n        if ( ! tappedTwice ) {\r\n\r\n          tappedTwice = true;\r\n          setTimeout( () => tappedTwice = false, 300 );\r\n          return false;\r\n\r\n        }\r\n\r\n        this.game( SHOW );\r\n\r\n      } else if ( this.state === STATE.Complete ) {\r\n\r\n        this.complete( HIDE );\r\n\r\n      } else if ( this.state === STATE.Stats ) {\r\n\r\n        this.stats( HIDE );\r\n\r\n      } \r\n\r\n    }, false );\r\n\r\n    this.controls.onMove = () => {\r\n\r\n      if ( this.newGame ) {\r\n        \r\n        this.timer.start( true );\r\n        this.newGame = false;\r\n\r\n      }\r\n\r\n    };\r\n\r\n    this.dom.buttons.back.onclick = event => {\r\n\r\n      if ( this.transition.activeTransitions > 0 ) return;\r\n\r\n      if ( this.state === STATE.Playing ) {\r\n\r\n        this.game( HIDE );\r\n\r\n      } else if ( this.state === STATE.Prefs ) {\r\n\r\n        this.prefs( HIDE );\r\n\r\n      } else if ( this.state === STATE.Theme ) {\r\n\r\n        this.theme( HIDE );\r\n\r\n      }\r\n\r\n    };\r\n\r\n    this.dom.buttons.reset.onclick = event => {\r\n\r\n      if ( this.state === STATE.Theme ) {\r\n\r\n        this.themeEditor.resetTheme();\r\n\r\n      }\r\n      \r\n    };\r\n\r\n    this.dom.buttons.prefs.onclick = event => this.prefs( SHOW );\r\n\r\n    this.dom.buttons.theme.onclick = event => this.theme( SHOW );\r\n\r\n    this.dom.buttons.stats.onclick = event => this.stats( SHOW );\r\n\r\n    this.controls.onSolved = () => this.complete( SHOW );\r\n\r\n  }\r\n\r\n  game( show ) {\r\n\r\n    if ( show ) {\r\n\r\n      if ( ! this.saved ) {\r\n\r\n        this.scrambler.scramble();\r\n        this.controls.scrambleCube();\r\n        this.newGame = true;\r\n\r\n      }\r\n\r\n      const duration = this.saved ? 0 :\r\n        this.scrambler.converted.length * ( this.controls.flipSpeeds[0] + 10 );\r\n\r\n      this.state = STATE.Playing;\r\n      this.saved = true;\r\n\r\n      this.transition.buttons( BUTTONS.None, BUTTONS.Menu );\r\n\r\n      this.transition.zoom( STATE.Playing, duration );\r\n      this.transition.title( HIDE );\r\n\r\n      setTimeout( () => {\r\n\r\n        this.transition.timer( SHOW );\r\n        this.transition.buttons( BUTTONS.Playing, BUTTONS.None );\r\n\r\n      }, this.transition.durations.zoom - 1000 );\r\n\r\n      setTimeout( () => {\r\n\r\n        this.controls.enable();\r\n        if ( ! this.newGame ) this.timer.start( true );\r\n\r\n      }, this.transition.durations.zoom );\r\n\r\n    } else {\r\n\r\n      this.state = STATE.Menu;\r\n\r\n      this.transition.buttons( BUTTONS.Menu, BUTTONS.Playing );\r\n\r\n      this.transition.zoom( STATE.Menu, 0 );\r\n\r\n      this.controls.disable();\r\n      if ( ! this.newGame ) this.timer.stop();\r\n      this.transition.timer( HIDE );\r\n\r\n      setTimeout( () => this.transition.title( SHOW ), this.transition.durations.zoom - 1000 );\r\n\r\n      this.playing = false;\r\n      this.controls.disable();\r\n\r\n    }\r\n\r\n  }\r\n\r\n  prefs( show ) {\r\n\r\n    if ( show ) {\r\n\r\n      if ( this.transition.activeTransitions > 0 ) return;\r\n\r\n      this.state = STATE.Prefs;\r\n\r\n      this.transition.buttons( BUTTONS.Prefs, BUTTONS.Menu );\r\n\r\n      this.transition.title( HIDE );\r\n      this.transition.cube( HIDE );\r\n\r\n      setTimeout( () => this.transition.preferences( SHOW ), 1000 );\r\n\r\n    } else {\r\n\r\n      this.cube.resize();\r\n\r\n      this.state = STATE.Menu;\r\n\r\n      this.transition.buttons( BUTTONS.Menu, BUTTONS.Prefs );\r\n\r\n      this.transition.preferences( HIDE );\r\n\r\n      setTimeout( () => this.transition.cube( SHOW ), 500 );\r\n      setTimeout( () => this.transition.title( SHOW ), 1200 );\r\n\r\n    }\r\n\r\n  }\r\n\r\n  theme( show ) {\r\n\r\n    this.themeEditor.colorPicker( show );\r\n    \r\n    if ( show ) {\r\n\r\n      if ( this.transition.activeTransitions > 0 ) return;\r\n\r\n      this.cube.loadFromData( States[ '3' ][ 'checkerboard' ] );\r\n\r\n      this.themeEditor.setHSL( null, false );\r\n\r\n      this.state = STATE.Theme;\r\n\r\n      this.transition.buttons( BUTTONS.Theme, BUTTONS.Prefs );\r\n\r\n      this.transition.preferences( HIDE );\r\n\r\n      setTimeout( () => this.transition.cube( SHOW, true ), 500 );\r\n      setTimeout( () => this.transition.theming( SHOW ), 1000 );\r\n\r\n    } else {\r\n\r\n      this.state = STATE.Prefs;\r\n\r\n      this.transition.buttons( BUTTONS.Prefs, BUTTONS.Theme );\r\n\r\n      this.transition.cube( HIDE, true );\r\n      this.transition.theming( HIDE );\r\n\r\n      setTimeout( () => this.transition.preferences( SHOW ), 1000 );\r\n      setTimeout( () => {\r\n\r\n        const gameCubeData = JSON.parse( localStorage.getItem( 'theCube_savedState' ) );\r\n\r\n        if ( !gameCubeData ) {\r\n\r\n          this.cube.resize( true );\r\n          return;\r\n\r\n        }\r\n\r\n        this.cube.loadFromData( gameCubeData );\r\n\r\n      }, 1500 );\r\n\r\n    }\r\n\r\n  }\r\n\r\n  stats( show ) {\r\n\r\n    if ( show ) {\r\n\r\n      if ( this.transition.activeTransitions > 0 ) return;\r\n\r\n      this.state = STATE.Stats;\r\n\r\n      this.transition.buttons( BUTTONS.Stats, BUTTONS.Menu );\r\n\r\n      this.transition.title( HIDE );\r\n      this.transition.cube( HIDE );\r\n\r\n      setTimeout( () => this.transition.stats( SHOW ), 1000 );\r\n\r\n    } else {\r\n\r\n      this.state = STATE.Menu;\r\n\r\n      this.transition.buttons( BUTTONS.Menu, BUTTONS.None );\r\n\r\n      this.transition.stats( HIDE );\r\n\r\n      setTimeout( () => this.transition.cube( SHOW ), 500 );\r\n      setTimeout( () => this.transition.title( SHOW ), 1200 );\r\n\r\n    }\r\n\r\n  }\r\n\r\n  complete( show ) {\r\n\r\n    if ( show ) {\r\n\r\n      this.transition.buttons( BUTTONS.Complete, BUTTONS.Playing );\r\n\r\n      this.state = STATE.Complete;\r\n      this.saved = false;\r\n\r\n      this.controls.disable();\r\n      this.timer.stop();\r\n      this.storage.clearGame();\r\n\r\n      this.bestTime = this.scores.addScore( this.timer.deltaTime );\r\n\r\n      this.transition.zoom( STATE.Menu, 0 );\r\n      this.transition.elevate( SHOW );\r\n\r\n      setTimeout( () => {\r\n\r\n        this.transition.complete( SHOW, this.bestTime );\r\n        this.confetti.start();\r\n\r\n      }, 1000 );\r\n\r\n    } else {\r\n\r\n      this.state = STATE.Stats;\r\n      this.saved = false;\r\n\r\n      this.transition.timer( HIDE );\r\n      this.transition.complete( HIDE, this.bestTime );\r\n      this.transition.cube( HIDE );\r\n      this.timer.reset();\r\n\r\n      setTimeout( () => {\r\n\r\n        this.cube.reset();\r\n        this.confetti.stop();\r\n\r\n        this.transition.stats( SHOW );\r\n        this.transition.elevate( 0 );\r\n\r\n      }, 1000 );\r\n\r\n      return false;\r\n\r\n    }\r\n\r\n  }\r\n\r\n}\r\n\r\nwindow.version = '0.99.2';\r\nwindow.game = new Game();",
            "description": ""
        },
        "main.sass": {
            "filename": "main.sass",
            "fileType": "txt",
            "type": "text/scss",
            "language": "scss",
            "size": 0,
            "truncated": false,
            "content": "@font-face\r\n  font-family: 'BungeeFont'\r\n  font-weight: normal\r\n  font-style: normal\r\n  src: url('data:font/truetype;charset=utf-8;base64,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') format('woff2'), url('data:font/truetype;charset=utf-8;base64,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') format('woff')\r\n\r\n=inset($position: absolute)\r\n  position: $position\r\n  top: 0\r\n  left: 0\r\n  width: 100%\r\n  height: 100%\r\n\r\n*\r\n  &,\r\n  &:before,\r\n  &:after\r\n    -webkit-user-select: none\r\n    -moz-user-select: none\r\n    user-select: none\r\n    box-sizing: border-box\r\n    cursor: inherit\r\n    margin: 0\r\n    padding: 0\r\n    outline: none\r\n    font-size: inherit\r\n    font-family: inherit\r\n    font-weight: inherit\r\n    font-style: inherit\r\n    text-transform: uppercase\r\n\r\n  &:focus\r\n    outline: none\r\n\r\nhtml\r\n  -webkit-tap-highlight-color: transparent\r\n  -webkit-text-size-adjust: 100%\r\n  -webkit-font-smoothing: antialiased\r\n  -moz-osx-font-smoothing: grayscale\r\n  -ms-text-size-adjust: 100%\r\n  -webkit-text-size-adjust: 100%\r\n  overflow: hidden\r\n  height: 100%\r\n\r\nbody\r\n  font-family: 'BungeeFont', sans-serif\r\n  font-weight: normal\r\n  font-style: normal\r\n  line-height: 1\r\n  cursor: default\r\n  overflow: hidden\r\n  height: 100%\r\n  font-size: 5rem\r\n\r\n.icon\r\n  display: inline-block\r\n  font-size: inherit\r\n  overflow: visible\r\n  vertical-align: -0.125em\r\n  preserveAspectRatio: none\r\n  \r\n.range\r\n  position: relative\r\n  width: 14em\r\n  z-index: 1\r\n  opacity: 0\r\n\r\n  &:not(:last-child)\r\n    margin-bottom: 2em\r\n\r\n  &__label\r\n    position: relative\r\n    font-size: 0.9em\r\n    line-height: 0.75em\r\n    padding-bottom: 0.5em\r\n    z-index: 2\r\n\r\n  &__track\r\n    position: relative\r\n    height: 1em\r\n    margin-left: 0.5em\r\n    margin-right: 0.5em\r\n    z-index: 3\r\n\r\n    &-line\r\n      position: absolute\r\n      background: rgba(#000, 0.2)\r\n      height: 2px\r\n      top: 50%\r\n      margin-top: -1px\r\n      left: -0.5em\r\n      right: -0.5em\r\n      transform-origin: left center\r\n\r\n  &__handle\r\n    position: absolute\r\n    width: 0\r\n    height: 0\r\n    top: 50%\r\n    left: 0\r\n    cursor: pointer\r\n    z-index: 1\r\n\r\n    div\r\n      transition: background 500ms ease\r\n      position: absolute\r\n      left: 0\r\n      top: 0\r\n      width: 0.9em\r\n      height: 0.9em\r\n      border-radius: 0.2em\r\n      margin-left: -0.45em\r\n      margin-top: -0.45em\r\n      background: #41aac8\r\n      border-bottom: 2px solid rgba(#000, 0.2)\r\n\r\n      .range.is-active &\r\n        transform: scale(1.25)\r\n\r\n    &:after\r\n      content: ''\r\n      position: absolute\r\n      left: 0\r\n      top: 0\r\n      width: 3em\r\n      height: 3em\r\n      margin-left: -1.5em\r\n      margin-top: -1.5em\r\n\r\n  &__list\r\n    display: flex\r\n    flex-flow: row nowrap\r\n    justify-content: space-between\r\n    position: relative\r\n    padding-top: 0.5em\r\n    font-size: 0.55em\r\n    color: rgba(#000, 0.5)\r\n    z-index: 1\r\n\r\n  &--type\r\n    &-color\r\n      &:not(:last-child)\r\n        margin-bottom: 1em\r\n\r\n      .range\r\n        &__list\r\n          display: none\r\n\r\n        &__handle\r\n          > div\r\n            background: currentColor !important\r\n\r\n        &__track\r\n          &-line\r\n            background: transparent\r\n\r\n            &:after\r\n              +inset\r\n              content: ''\r\n              opacity: 0.5\r\n\r\n  &--color\r\n    &-hue\r\n      .range\r\n        &__handle\r\n          color: red\r\n\r\n        &__track\r\n          color: red\r\n\r\n          &-line\r\n            &:after\r\n              background: linear-gradient(to right, red, yellow, lime, cyan, blue, magenta, red)\r\n              \r\n\r\n    &-saturation\r\n      .range\r\n        &__handle\r\n          color: red\r\n\r\n        &__track\r\n          color: red\r\n\r\n          &-line\r\n            &:after\r\n              background: linear-gradient(to right, gray, currentColor)\r\n\r\n    &-lightness\r\n      .range\r\n        &__handle\r\n          color: red\r\n\r\n        &__track\r\n          color: red\r\n\r\n          &-line\r\n            &:after\r\n              background: linear-gradient(to right, black, currentColor, white)\r\n\r\n.stats\r\n  position: relative\r\n  width: 14em\r\n  z-index: 1\r\n  display: flex\r\n  justify-content: space-between\r\n  opacity: 0\r\n\r\n  &:not(:last-child)\r\n    margin-bottom: 1.5em\r\n\r\n  > i\r\n    display: block\r\n    color: rgba(#000, 0.5)\r\n    font-size: 0.9em\r\n\r\n  > b\r\n    display: block\r\n    font-size: 0.9em\r\n\r\n    > i\r\n      font-size: 0.75em\r\n\r\n  &[name=\"worst-time\"]\r\n    display: none\r\n\r\n.text\r\n  position: absolute\r\n  left: 0\r\n  right: 0\r\n  text-align: center\r\n  line-height: 0.75\r\n  perspective: 100rem\r\n  opacity: 0\r\n\r\n  i\r\n    display: inline-block\r\n    opacity: 0\r\n    white-space: pre-wrap\r\n\r\n  &--title\r\n    bottom: 75%\r\n    font-size: 4.4em\r\n    height: 1.2em\r\n\r\n    span\r\n      display: block\r\n\r\n      &:first-child\r\n        font-size: 0.5em\r\n        margin-bottom: 0.2em\r\n\r\n  &--note\r\n    top: 87%\r\n    font-size: 1em\r\n\r\n  &--timer\r\n    bottom: 78%\r\n    font-size: 3.5em\r\n    line-height: 1\r\n\r\n  &--complete,\r\n  &--best-time\r\n    font-size: 1.5em\r\n    top: 83%\r\n    line-height: 1em\r\n\r\n.btn\r\n  -webkit-appearance: none\r\n  -moz-appearance: none\r\n  appearance: none\r\n  background-color: transparent\r\n  border-radius: 0\r\n  border-width: 0\r\n  position: absolute\r\n  pointer-events: none\r\n  font-size: 1.2em\r\n  color: rgba(#000, 0.25)\r\n  opacity: 0\r\n\r\n  &:after\r\n    position: absolute\r\n    content: ''\r\n    width: 3em\r\n    height: 3em\r\n    left: 50%\r\n    top: 50%\r\n    margin-left: -1.5em\r\n    margin-top: -1.5em\r\n    border-radius: 100%\r\n\r\n  &--bl\r\n    bottom: 0.8em\r\n    left: 0.8em\r\n\r\n  &--br\r\n    bottom: 0.8em\r\n    right: 0.8em\r\n\r\n  &--bc\r\n    bottom: 0.8em\r\n    left: calc(50% - 0.5em)\r\n\r\n  svg \r\n    display: block\r\n\r\n  &--cancel\r\n    display: none !important\r\n.ui\r\n  pointer-events: none\r\n  color: #070d15\r\n\r\n  &,\r\n  &__background,\r\n  &__game,\r\n  &__texts,\r\n  &__prefs,\r\n  &__theme,\r\n  &__stats,\r\n  &__buttons\r\n    +inset\r\n    overflow: hidden\r\n\r\n  &__background\r\n    z-index: 1\r\n    transition: background 500ms ease\r\n    background: #d1d5db\r\n\r\n    &:after\r\n      +inset\r\n      content: ''\r\n      background-image: linear-gradient(to bottom, rgba(#fff, 1) 50%, rgba(#fff, 0) 100%)\r\n\r\n  &__game\r\n    pointer-events: all\r\n    z-index: 2\r\n\r\n    canvas\r\n      display: block\r\n      width: 100%\r\n      height: 100%\r\n\r\n  &__texts\r\n    z-index: 3\r\n\r\n  &__prefs,\r\n  &__stats,\r\n  &__theme\r\n    display: flex\r\n    flex-flow: column nowrap\r\n    justify-content: center\r\n    align-items: center\r\n    overflow: hidden\r\n    z-index: 4\r\n\r\n  &__theme\r\n    padding-top: 15em\r\n\r\n  &__buttons\r\n    z-index: 5",
            "description": ""
        }
    },
    "public": true,
    "description": "",
    "projectName": "The Cube",
    "lastUpdatedTime": 1590908404835
}